// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: schema.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_schema_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_schema_2eproto

#define GOOGLE_DCHECK

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3013000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3013000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_schema_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_schema_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[15]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_schema_2eproto;
class ActiveProcess;
class ActiveProcessDefaultTypeInternal;
extern ActiveProcessDefaultTypeInternal _ActiveProcess_default_instance_;
class BackfillProgress;
class BackfillProgressDefaultTypeInternal;
extern BackfillProgressDefaultTypeInternal _BackfillProgress_default_instance_;
class BaseProductState;
class BaseProductStateDefaultTypeInternal;
extern BaseProductStateDefaultTypeInternal _BaseProductState_default_instance_;
class BuildConfig;
class BuildConfigDefaultTypeInternal;
extern BuildConfigDefaultTypeInternal _BuildConfig_default_instance_;
class CachedProductState;
class CachedProductStateDefaultTypeInternal;
extern CachedProductStateDefaultTypeInternal _CachedProductState_default_instance_;
class DownloadSettings;
class DownloadSettingsDefaultTypeInternal;
extern DownloadSettingsDefaultTypeInternal _DownloadSettings_default_instance_;
class InstallHandshake;
class InstallHandshakeDefaultTypeInternal;
extern InstallHandshakeDefaultTypeInternal _InstallHandshake_default_instance_;
class LanguageSetting;
class LanguageSettingDefaultTypeInternal;
extern LanguageSettingDefaultTypeInternal _LanguageSetting_default_instance_;
class ProductConfig;
class ProductConfigDefaultTypeInternal;
extern ProductConfigDefaultTypeInternal _ProductConfig_default_instance_;
class ProductDb;
class ProductDbDefaultTypeInternal;
extern ProductDbDefaultTypeInternal _ProductDb_default_instance_;
class ProductInstall;
class ProductInstallDefaultTypeInternal;
extern ProductInstallDefaultTypeInternal _ProductInstall_default_instance_;
class ProductOperations;
class ProductOperationsDefaultTypeInternal;
extern ProductOperationsDefaultTypeInternal _ProductOperations_default_instance_;
class RepairProgress;
class RepairProgressDefaultTypeInternal;
extern RepairProgressDefaultTypeInternal _RepairProgress_default_instance_;
class UpdateProgress;
class UpdateProgressDefaultTypeInternal;
extern UpdateProgressDefaultTypeInternal _UpdateProgress_default_instance_;
class UserSettings;
class UserSettingsDefaultTypeInternal;
extern UserSettingsDefaultTypeInternal _UserSettings_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> auto Arena::CreateMaybeMessage<::ActiveProcess>(Arena*) -> ::ActiveProcess*;
template<> auto Arena::CreateMaybeMessage<::BackfillProgress>(Arena*) -> ::BackfillProgress*;
template<> auto Arena::CreateMaybeMessage<::BaseProductState>(Arena*) -> ::BaseProductState*;
template<> auto Arena::CreateMaybeMessage<::BuildConfig>(Arena*) -> ::BuildConfig*;
template<> auto Arena::CreateMaybeMessage<::CachedProductState>(Arena*) -> ::CachedProductState*;
template<> auto Arena::CreateMaybeMessage<::DownloadSettings>(Arena*) -> ::DownloadSettings*;
template<> auto Arena::CreateMaybeMessage<::InstallHandshake>(Arena*) -> ::InstallHandshake*;
template<> auto Arena::CreateMaybeMessage<::LanguageSetting>(Arena*) -> ::LanguageSetting*;
template<> auto Arena::CreateMaybeMessage<::ProductConfig>(Arena*) -> ::ProductConfig*;
template<> auto Arena::CreateMaybeMessage<::ProductDb>(Arena*) -> ::ProductDb*;
template<> auto Arena::CreateMaybeMessage<::ProductInstall>(Arena*) -> ::ProductInstall*;
template<> auto Arena::CreateMaybeMessage<::ProductOperations>(Arena*) -> ::ProductOperations*;
template<> auto Arena::CreateMaybeMessage<::RepairProgress>(Arena*) -> ::RepairProgress*;
template<> auto Arena::CreateMaybeMessage<::UpdateProgress>(Arena*) -> ::UpdateProgress*;
template<> auto Arena::CreateMaybeMessage<::UserSettings>(Arena*) -> ::UserSettings*;
PROTOBUF_NAMESPACE_CLOSE

enum LanguageOption : int {
  LANGOPTION_NONE = 0,
  LANGOPTION_TEXT = 1,
  LANGOPTION_SPEECH = 2,
  LANGOPTION_TEXT_AND_SPEECH = 3,
  LanguageOption_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  LanguageOption_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
auto LanguageOption_IsValid(int value) -> bool;
constexpr LanguageOption LanguageOption_MIN = LANGOPTION_NONE;
constexpr LanguageOption LanguageOption_MAX = LANGOPTION_TEXT_AND_SPEECH;
constexpr int LanguageOption_ARRAYSIZE = LanguageOption_MAX + 1;

auto LanguageOption_descriptor() -> const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*;
template<typename T>
inline auto LanguageOption_Name(T enum_t_value) -> const std::string& {
  static_assert(::std::is_same<T, LanguageOption>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LanguageOption_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LanguageOption_descriptor(), enum_t_value);
}
inline auto LanguageOption_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LanguageOption* value) -> bool {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LanguageOption>(
    LanguageOption_descriptor(), name, value);
}
enum LanguageSettingType : int {
  LANGSETTING_NONE = 0,
  LANGSETTING_SINGLE = 1,
  LANGSETTING_SIMPLE = 2,
  LANGSETTING_ADVANCED = 3,
  LanguageSettingType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  LanguageSettingType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
auto LanguageSettingType_IsValid(int value) -> bool;
constexpr LanguageSettingType LanguageSettingType_MIN = LANGSETTING_NONE;
constexpr LanguageSettingType LanguageSettingType_MAX = LANGSETTING_ADVANCED;
constexpr int LanguageSettingType_ARRAYSIZE = LanguageSettingType_MAX + 1;

auto LanguageSettingType_descriptor() -> const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*;
template<typename T>
inline auto LanguageSettingType_Name(T enum_t_value) -> const std::string& {
  static_assert(::std::is_same<T, LanguageSettingType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LanguageSettingType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LanguageSettingType_descriptor(), enum_t_value);
}
inline auto LanguageSettingType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LanguageSettingType* value) -> bool {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LanguageSettingType>(
    LanguageSettingType_descriptor(), name, value);
}
enum ShortcutOption : int {
  SHORTCUT_NONE = 0,
  SHORTCUT_USER = 1,
  SHORTCUT_ALL_USERS = 2,
  ShortcutOption_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ShortcutOption_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
auto ShortcutOption_IsValid(int value) -> bool;
constexpr ShortcutOption ShortcutOption_MIN = SHORTCUT_NONE;
constexpr ShortcutOption ShortcutOption_MAX = SHORTCUT_ALL_USERS;
constexpr int ShortcutOption_ARRAYSIZE = ShortcutOption_MAX + 1;

auto ShortcutOption_descriptor() -> const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*;
template<typename T>
inline auto ShortcutOption_Name(T enum_t_value) -> const std::string& {
  static_assert(::std::is_same<T, ShortcutOption>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ShortcutOption_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ShortcutOption_descriptor(), enum_t_value);
}
inline auto ShortcutOption_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ShortcutOption* value) -> bool {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ShortcutOption>(
    ShortcutOption_descriptor(), name, value);
}
enum Operation : int {
  OP_UPDATE = 0,
  OP_BACKFILL = 1,
  OP_REPAIR = 2,
  OP_NONE = -1,
  Operation_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Operation_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
auto Operation_IsValid(int value) -> bool;
constexpr Operation Operation_MIN = OP_NONE;
constexpr Operation Operation_MAX = OP_REPAIR;
constexpr int Operation_ARRAYSIZE = Operation_MAX + 1;

auto Operation_descriptor() -> const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*;
template<typename T>
inline auto Operation_Name(T enum_t_value) -> const std::string& {
  static_assert(::std::is_same<T, Operation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Operation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Operation_descriptor(), enum_t_value);
}
inline auto Operation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Operation* value) -> bool {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Operation>(
    Operation_descriptor(), name, value);
}
// ===================================================================

class LanguageSetting PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LanguageSetting) */ {
 public:
  inline LanguageSetting() : LanguageSetting(nullptr) {}
  ~LanguageSetting() override;

  LanguageSetting(const LanguageSetting& from);
  LanguageSetting(LanguageSetting&& from) noexcept
    : LanguageSetting() {
    *this = ::std::move(from);
  }

  inline auto operator=(const LanguageSetting& from) -> LanguageSetting& {
    CopyFrom(from);
    return *this;
  }
  inline auto operator=(LanguageSetting&& from) noexcept -> LanguageSetting& {
    if (GetArena() == from.GetArena()) {
      if (this != &from) { InternalSwap(&from);
}
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static auto descriptor() -> const ::PROTOBUF_NAMESPACE_ID::Descriptor* {
    return GetDescriptor();
  }
  static auto GetDescriptor() -> const ::PROTOBUF_NAMESPACE_ID::Descriptor* {
    return GetMetadataStatic().descriptor;
  }
  static auto GetReflection() -> const ::PROTOBUF_NAMESPACE_ID::Reflection* {
    return GetMetadataStatic().reflection;
  }
  static auto default_instance() -> const LanguageSetting&;

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline auto internal_default_instance() -> const LanguageSetting* {
    return reinterpret_cast<const LanguageSetting*>(
               &_LanguageSetting_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LanguageSetting& a, LanguageSetting& b) {
    a.Swap(&b);
  }
  inline void Swap(LanguageSetting* other) {
    if (other == this) { return;
}
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LanguageSetting* other) {
    if (other == this) { return;
}
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline auto New() const -> LanguageSetting* final {
    return CreateMaybeMessage<LanguageSetting>(nullptr);
  }

  auto New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const -> LanguageSetting* final {
    return CreateMaybeMessage<LanguageSetting>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LanguageSetting& from);
  void MergeFrom(const LanguageSetting& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  auto IsInitialized() const -> bool final;

  auto ByteSizeLong() const -> size_t final;
  auto _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) -> const char* final;
  auto _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const -> ::PROTOBUF_NAMESPACE_ID::uint8* final;
  auto GetCachedSize() const -> int final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LanguageSetting* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static auto FullMessageName() -> ::PROTOBUF_NAMESPACE_ID::StringPiece {
    return "LanguageSetting";
  }
  protected:
  explicit LanguageSetting(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  auto GetMetadata() const -> ::PROTOBUF_NAMESPACE_ID::Metadata final;
  private:
  static auto GetMetadataStatic() -> ::PROTOBUF_NAMESPACE_ID::Metadata {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schema_2eproto);
    return ::descriptor_table_schema_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLanguageFieldNumber = 1,
    kOptionFieldNumber = 2,
  };
  // string language = 1;
  void clear_language();
  auto language() const -> const std::string&;
  void set_language(const std::string& value);
  void set_language(std::string&& value);
  void set_language(const char* value);
  void set_language(const char* value, size_t size);
  auto mutable_language() -> std::string*;
  auto release_language() -> std::string*;
  void set_allocated_language(std::string* language);
  private:
  auto _internal_language() const -> const std::string&;
  void _internal_set_language(const std::string& value);
  auto _internal_mutable_language() -> std::string*;
  public:

  // .LanguageOption option = 2;
  void clear_option();
  auto option() const -> ::LanguageOption;
  void set_option(::LanguageOption value);
  private:
  auto _internal_option() const -> ::LanguageOption;
  void _internal_set_option(::LanguageOption value);
  public:

  // @@protoc_insertion_point(class_scope:LanguageSetting)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  using DestructorSkippable_ = void;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
  int option_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class UserSettings PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserSettings) */ {
 public:
  inline UserSettings() : UserSettings(nullptr) {}
  ~UserSettings() override;

  UserSettings(const UserSettings& from);
  UserSettings(UserSettings&& from) noexcept
    : UserSettings() {
    *this = ::std::move(from);
  }

  inline auto operator=(const UserSettings& from) -> UserSettings& {
    CopyFrom(from);
    return *this;
  }
  inline auto operator=(UserSettings&& from) noexcept -> UserSettings& {
    if (GetArena() == from.GetArena()) {
      if (this != &from) { InternalSwap(&from);
}
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static auto descriptor() -> const ::PROTOBUF_NAMESPACE_ID::Descriptor* {
    return GetDescriptor();
  }
  static auto GetDescriptor() -> const ::PROTOBUF_NAMESPACE_ID::Descriptor* {
    return GetMetadataStatic().descriptor;
  }
  static auto GetReflection() -> const ::PROTOBUF_NAMESPACE_ID::Reflection* {
    return GetMetadataStatic().reflection;
  }
  static auto default_instance() -> const UserSettings&;

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline auto internal_default_instance() -> const UserSettings* {
    return reinterpret_cast<const UserSettings*>(
               &_UserSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UserSettings& a, UserSettings& b) {
    a.Swap(&b);
  }
  inline void Swap(UserSettings* other) {
    if (other == this) { return;
}
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserSettings* other) {
    if (other == this) { return;
}
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline auto New() const -> UserSettings* final {
    return CreateMaybeMessage<UserSettings>(nullptr);
  }

  auto New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const -> UserSettings* final {
    return CreateMaybeMessage<UserSettings>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UserSettings& from);
  void MergeFrom(const UserSettings& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  auto IsInitialized() const -> bool final;

  auto ByteSizeLong() const -> size_t final;
  auto _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) -> const char* final;
  auto _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const -> ::PROTOBUF_NAMESPACE_ID::uint8* final;
  auto GetCachedSize() const -> int final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserSettings* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static auto FullMessageName() -> ::PROTOBUF_NAMESPACE_ID::StringPiece {
    return "UserSettings";
  }
  protected:
  explicit UserSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  auto GetMetadata() const -> ::PROTOBUF_NAMESPACE_ID::Metadata final;
  private:
  static auto GetMetadataStatic() -> ::PROTOBUF_NAMESPACE_ID::Metadata {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schema_2eproto);
    return ::descriptor_table_schema_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLanguagesFieldNumber = 8,
    kInstallPathFieldNumber = 1,
    kPlayRegionFieldNumber = 2,
    kSelectedTextLanguageFieldNumber = 6,
    kSelectedSpeechLanguageFieldNumber = 7,
    kGfxOverrideTagsFieldNumber = 9,
    kVersionbranchFieldNumber = 10,
    kDesktopShortcutFieldNumber = 3,
    kStartmenuShortcutFieldNumber = 4,
    kLanguageSettingsFieldNumber = 5,
  };
  // repeated .LanguageSetting languages = 8;
  auto languages_size() const -> int;
  private:
  auto _internal_languages_size() const -> int;
  public:
  void clear_languages();
  auto mutable_languages(int index) -> ::LanguageSetting*;
  auto
      mutable_languages() -> ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LanguageSetting >*;
  private:
  auto _internal_languages(int index) const -> const ::LanguageSetting&;
  auto _internal_add_languages() -> ::LanguageSetting*;
  public:
  auto languages(int index) const -> const ::LanguageSetting&;
  auto add_languages() -> ::LanguageSetting*;
  auto
      languages() const -> const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LanguageSetting >&;

  // string install_path = 1;
  void clear_install_path();
  auto install_path() const -> const std::string&;
  void set_install_path(const std::string& value);
  void set_install_path(std::string&& value);
  void set_install_path(const char* value);
  void set_install_path(const char* value, size_t size);
  auto mutable_install_path() -> std::string*;
  auto release_install_path() -> std::string*;
  void set_allocated_install_path(std::string* install_path);
  private:
  auto _internal_install_path() const -> const std::string&;
  void _internal_set_install_path(const std::string& value);
  auto _internal_mutable_install_path() -> std::string*;
  public:

  // string play_region = 2;
  void clear_play_region();
  auto play_region() const -> const std::string&;
  void set_play_region(const std::string& value);
  void set_play_region(std::string&& value);
  void set_play_region(const char* value);
  void set_play_region(const char* value, size_t size);
  auto mutable_play_region() -> std::string*;
  auto release_play_region() -> std::string*;
  void set_allocated_play_region(std::string* play_region);
  private:
  auto _internal_play_region() const -> const std::string&;
  void _internal_set_play_region(const std::string& value);
  auto _internal_mutable_play_region() -> std::string*;
  public:

  // string selected_text_language = 6;
  void clear_selected_text_language();
  auto selected_text_language() const -> const std::string&;
  void set_selected_text_language(const std::string& value);
  void set_selected_text_language(std::string&& value);
  void set_selected_text_language(const char* value);
  void set_selected_text_language(const char* value, size_t size);
  auto mutable_selected_text_language() -> std::string*;
  auto release_selected_text_language() -> std::string*;
  void set_allocated_selected_text_language(std::string* selected_text_language);
  private:
  auto _internal_selected_text_language() const -> const std::string&;
  void _internal_set_selected_text_language(const std::string& value);
  auto _internal_mutable_selected_text_language() -> std::string*;
  public:

  // string selected_speech_language = 7;
  void clear_selected_speech_language();
  auto selected_speech_language() const -> const std::string&;
  void set_selected_speech_language(const std::string& value);
  void set_selected_speech_language(std::string&& value);
  void set_selected_speech_language(const char* value);
  void set_selected_speech_language(const char* value, size_t size);
  auto mutable_selected_speech_language() -> std::string*;
  auto release_selected_speech_language() -> std::string*;
  void set_allocated_selected_speech_language(std::string* selected_speech_language);
  private:
  auto _internal_selected_speech_language() const -> const std::string&;
  void _internal_set_selected_speech_language(const std::string& value);
  auto _internal_mutable_selected_speech_language() -> std::string*;
  public:

  // string gfx_override_tags = 9;
  void clear_gfx_override_tags();
  auto gfx_override_tags() const -> const std::string&;
  void set_gfx_override_tags(const std::string& value);
  void set_gfx_override_tags(std::string&& value);
  void set_gfx_override_tags(const char* value);
  void set_gfx_override_tags(const char* value, size_t size);
  auto mutable_gfx_override_tags() -> std::string*;
  auto release_gfx_override_tags() -> std::string*;
  void set_allocated_gfx_override_tags(std::string* gfx_override_tags);
  private:
  auto _internal_gfx_override_tags() const -> const std::string&;
  void _internal_set_gfx_override_tags(const std::string& value);
  auto _internal_mutable_gfx_override_tags() -> std::string*;
  public:

  // string versionbranch = 10;
  void clear_versionbranch();
  auto versionbranch() const -> const std::string&;
  void set_versionbranch(const std::string& value);
  void set_versionbranch(std::string&& value);
  void set_versionbranch(const char* value);
  void set_versionbranch(const char* value, size_t size);
  auto mutable_versionbranch() -> std::string*;
  auto release_versionbranch() -> std::string*;
  void set_allocated_versionbranch(std::string* versionbranch);
  private:
  auto _internal_versionbranch() const -> const std::string&;
  void _internal_set_versionbranch(const std::string& value);
  auto _internal_mutable_versionbranch() -> std::string*;
  public:

  // .ShortcutOption desktop_shortcut = 3;
  void clear_desktop_shortcut();
  auto desktop_shortcut() const -> ::ShortcutOption;
  void set_desktop_shortcut(::ShortcutOption value);
  private:
  auto _internal_desktop_shortcut() const -> ::ShortcutOption;
  void _internal_set_desktop_shortcut(::ShortcutOption value);
  public:

  // .ShortcutOption startmenu_shortcut = 4;
  void clear_startmenu_shortcut();
  auto startmenu_shortcut() const -> ::ShortcutOption;
  void set_startmenu_shortcut(::ShortcutOption value);
  private:
  auto _internal_startmenu_shortcut() const -> ::ShortcutOption;
  void _internal_set_startmenu_shortcut(::ShortcutOption value);
  public:

  // .LanguageSettingType language_settings = 5;
  void clear_language_settings();
  auto language_settings() const -> ::LanguageSettingType;
  void set_language_settings(::LanguageSettingType value);
  private:
  auto _internal_language_settings() const -> ::LanguageSettingType;
  void _internal_set_language_settings(::LanguageSettingType value);
  public:

  // @@protoc_insertion_point(class_scope:UserSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LanguageSetting > languages_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr install_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr play_region_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr selected_text_language_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr selected_speech_language_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gfx_override_tags_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr versionbranch_;
  int desktop_shortcut_;
  int startmenu_shortcut_;
  int language_settings_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class InstallHandshake PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:InstallHandshake) */ {
 public:
  inline InstallHandshake() : InstallHandshake(nullptr) {}
  ~InstallHandshake() override;

  InstallHandshake(const InstallHandshake& from);
  InstallHandshake(InstallHandshake&& from) noexcept
    : InstallHandshake() {
    *this = ::std::move(from);
  }

  inline auto operator=(const InstallHandshake& from) -> InstallHandshake& {
    CopyFrom(from);
    return *this;
  }
  inline auto operator=(InstallHandshake&& from) noexcept -> InstallHandshake& {
    if (GetArena() == from.GetArena()) {
      if (this != &from) { InternalSwap(&from);
}
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static auto descriptor() -> const ::PROTOBUF_NAMESPACE_ID::Descriptor* {
    return GetDescriptor();
  }
  static auto GetDescriptor() -> const ::PROTOBUF_NAMESPACE_ID::Descriptor* {
    return GetMetadataStatic().descriptor;
  }
  static auto GetReflection() -> const ::PROTOBUF_NAMESPACE_ID::Reflection* {
    return GetMetadataStatic().reflection;
  }
  static auto default_instance() -> const InstallHandshake&;

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline auto internal_default_instance() -> const InstallHandshake* {
    return reinterpret_cast<const InstallHandshake*>(
               &_InstallHandshake_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(InstallHandshake& a, InstallHandshake& b) {
    a.Swap(&b);
  }
  inline void Swap(InstallHandshake* other) {
    if (other == this) { return;
}
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstallHandshake* other) {
    if (other == this) { return;
}
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline auto New() const -> InstallHandshake* final {
    return CreateMaybeMessage<InstallHandshake>(nullptr);
  }

  auto New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const -> InstallHandshake* final {
    return CreateMaybeMessage<InstallHandshake>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InstallHandshake& from);
  void MergeFrom(const InstallHandshake& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  auto IsInitialized() const -> bool final;

  auto ByteSizeLong() const -> size_t final;
  auto _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) -> const char* final;
  auto _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const -> ::PROTOBUF_NAMESPACE_ID::uint8* final;
  auto GetCachedSize() const -> int final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstallHandshake* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static auto FullMessageName() -> ::PROTOBUF_NAMESPACE_ID::StringPiece {
    return "InstallHandshake";
  }
  protected:
  explicit InstallHandshake(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  auto GetMetadata() const -> ::PROTOBUF_NAMESPACE_ID::Metadata final;
  private:
  static auto GetMetadataStatic() -> ::PROTOBUF_NAMESPACE_ID::Metadata {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schema_2eproto);
    return ::descriptor_table_schema_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProductFieldNumber = 1,
    kUidFieldNumber = 2,
    kSettingsFieldNumber = 3,
  };
  // string product = 1;
  void clear_product();
  auto product() const -> const std::string&;
  void set_product(const std::string& value);
  void set_product(std::string&& value);
  void set_product(const char* value);
  void set_product(const char* value, size_t size);
  auto mutable_product() -> std::string*;
  auto release_product() -> std::string*;
  void set_allocated_product(std::string* product);
  private:
  auto _internal_product() const -> const std::string&;
  void _internal_set_product(const std::string& value);
  auto _internal_mutable_product() -> std::string*;
  public:

  // string uid = 2;
  void clear_uid();
  auto uid() const -> const std::string&;
  void set_uid(const std::string& value);
  void set_uid(std::string&& value);
  void set_uid(const char* value);
  void set_uid(const char* value, size_t size);
  auto mutable_uid() -> std::string*;
  auto release_uid() -> std::string*;
  void set_allocated_uid(std::string* uid);
  private:
  auto _internal_uid() const -> const std::string&;
  void _internal_set_uid(const std::string& value);
  auto _internal_mutable_uid() -> std::string*;
  public:

  // .UserSettings settings = 3;
  auto has_settings() const -> bool;
  private:
  auto _internal_has_settings() const -> bool;
  public:
  void clear_settings();
  auto settings() const -> const ::UserSettings&;
  auto release_settings() -> ::UserSettings*;
  auto mutable_settings() -> ::UserSettings*;
  void set_allocated_settings(::UserSettings* settings);
  private:
  auto _internal_settings() const -> const ::UserSettings&;
  auto _internal_mutable_settings() -> ::UserSettings*;
  public:
  void unsafe_arena_set_allocated_settings(
      ::UserSettings* settings);
  auto unsafe_arena_release_settings() -> ::UserSettings*;

  // @@protoc_insertion_point(class_scope:InstallHandshake)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr product_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
  ::UserSettings* settings_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class BuildConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BuildConfig) */ {
 public:
  inline BuildConfig() : BuildConfig(nullptr) {}
  ~BuildConfig() override;

  BuildConfig(const BuildConfig& from);
  BuildConfig(BuildConfig&& from) noexcept
    : BuildConfig() {
    *this = ::std::move(from);
  }

  inline auto operator=(const BuildConfig& from) -> BuildConfig& {
    CopyFrom(from);
    return *this;
  }
  inline auto operator=(BuildConfig&& from) noexcept -> BuildConfig& {
    if (GetArena() == from.GetArena()) {
      if (this != &from) { InternalSwap(&from);
}
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static auto descriptor() -> const ::PROTOBUF_NAMESPACE_ID::Descriptor* {
    return GetDescriptor();
  }
  static auto GetDescriptor() -> const ::PROTOBUF_NAMESPACE_ID::Descriptor* {
    return GetMetadataStatic().descriptor;
  }
  static auto GetReflection() -> const ::PROTOBUF_NAMESPACE_ID::Reflection* {
    return GetMetadataStatic().reflection;
  }
  static auto default_instance() -> const BuildConfig&;

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline auto internal_default_instance() -> const BuildConfig* {
    return reinterpret_cast<const BuildConfig*>(
               &_BuildConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(BuildConfig& a, BuildConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(BuildConfig* other) {
    if (other == this) { return;
}
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BuildConfig* other) {
    if (other == this) { return;
}
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline auto New() const -> BuildConfig* final {
    return CreateMaybeMessage<BuildConfig>(nullptr);
  }

  auto New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const -> BuildConfig* final {
    return CreateMaybeMessage<BuildConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BuildConfig& from);
  void MergeFrom(const BuildConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  auto IsInitialized() const -> bool final;

  auto ByteSizeLong() const -> size_t final;
  auto _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) -> const char* final;
  auto _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const -> ::PROTOBUF_NAMESPACE_ID::uint8* final;
  auto GetCachedSize() const -> int final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuildConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static auto FullMessageName() -> ::PROTOBUF_NAMESPACE_ID::StringPiece {
    return "BuildConfig";
  }
  protected:
  explicit BuildConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  auto GetMetadata() const -> ::PROTOBUF_NAMESPACE_ID::Metadata final;
  private:
  static auto GetMetadataStatic() -> ::PROTOBUF_NAMESPACE_ID::Metadata {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schema_2eproto);
    return ::descriptor_table_schema_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionFieldNumber = 1,
    kBuildConfigFieldNumber = 2,
  };
  // string region = 1;
  void clear_region();
  auto region() const -> const std::string&;
  void set_region(const std::string& value);
  void set_region(std::string&& value);
  void set_region(const char* value);
  void set_region(const char* value, size_t size);
  auto mutable_region() -> std::string*;
  auto release_region() -> std::string*;
  void set_allocated_region(std::string* region);
  private:
  auto _internal_region() const -> const std::string&;
  void _internal_set_region(const std::string& value);
  auto _internal_mutable_region() -> std::string*;
  public:

  // string build_config = 2;
  void clear_build_config();
  auto build_config() const -> const std::string&;
  void set_build_config(const std::string& value);
  void set_build_config(std::string&& value);
  void set_build_config(const char* value);
  void set_build_config(const char* value, size_t size);
  auto mutable_build_config() -> std::string*;
  auto release_build_config() -> std::string*;
  void set_allocated_build_config(std::string* build_config);
  private:
  auto _internal_build_config() const -> const std::string&;
  void _internal_set_build_config(const std::string& value);
  auto _internal_mutable_build_config() -> std::string*;
  public:

  // @@protoc_insertion_point(class_scope:BuildConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr build_config_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class BaseProductState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BaseProductState) */ {
 public:
  inline BaseProductState() : BaseProductState(nullptr) {}
  ~BaseProductState() override;

  BaseProductState(const BaseProductState& from);
  BaseProductState(BaseProductState&& from) noexcept
    : BaseProductState() {
    *this = ::std::move(from);
  }

  inline auto operator=(const BaseProductState& from) -> BaseProductState& {
    CopyFrom(from);
    return *this;
  }
  inline auto operator=(BaseProductState&& from) noexcept -> BaseProductState& {
    if (GetArena() == from.GetArena()) {
      if (this != &from) { InternalSwap(&from);
}
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static auto descriptor() -> const ::PROTOBUF_NAMESPACE_ID::Descriptor* {
    return GetDescriptor();
  }
  static auto GetDescriptor() -> const ::PROTOBUF_NAMESPACE_ID::Descriptor* {
    return GetMetadataStatic().descriptor;
  }
  static auto GetReflection() -> const ::PROTOBUF_NAMESPACE_ID::Reflection* {
    return GetMetadataStatic().reflection;
  }
  static auto default_instance() -> const BaseProductState&;

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline auto internal_default_instance() -> const BaseProductState* {
    return reinterpret_cast<const BaseProductState*>(
               &_BaseProductState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(BaseProductState& a, BaseProductState& b) {
    a.Swap(&b);
  }
  inline void Swap(BaseProductState* other) {
    if (other == this) { return;
}
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BaseProductState* other) {
    if (other == this) { return;
}
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline auto New() const -> BaseProductState* final {
    return CreateMaybeMessage<BaseProductState>(nullptr);
  }

  auto New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const -> BaseProductState* final {
    return CreateMaybeMessage<BaseProductState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BaseProductState& from);
  void MergeFrom(const BaseProductState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  auto IsInitialized() const -> bool final;

  auto ByteSizeLong() const -> size_t final;
  auto _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) -> const char* final;
  auto _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const -> ::PROTOBUF_NAMESPACE_ID::uint8* final;
  auto GetCachedSize() const -> int final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BaseProductState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static auto FullMessageName() -> ::PROTOBUF_NAMESPACE_ID::StringPiece {
    return "BaseProductState";
  }
  protected:
  explicit BaseProductState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  auto GetMetadata() const -> ::PROTOBUF_NAMESPACE_ID::Metadata final;
  private:
  static auto GetMetadataStatic() -> ::PROTOBUF_NAMESPACE_ID::Metadata {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schema_2eproto);
    return ::descriptor_table_schema_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstalledBuildConfigFieldNumber = 8,
    kBackgroundDownloadBuildConfigFieldNumber = 9,
    kCompletedInstallActionsFieldNumber = 11,
    kCurrentVersionFieldNumber = 6,
    kCurrentVersionStrFieldNumber = 7,
    kDecryptionKeyFieldNumber = 10,
    kInstalledFieldNumber = 1,
    kPlayableFieldNumber = 2,
    kUpdateCompleteFieldNumber = 3,
    kBackgroundDownloadAvailableFieldNumber = 4,
    kBackgroundDownloadCompleteFieldNumber = 5,
  };
  // repeated .BuildConfig installed_build_config = 8;
  auto installed_build_config_size() const -> int;
  private:
  auto _internal_installed_build_config_size() const -> int;
  public:
  void clear_installed_build_config();
  auto mutable_installed_build_config(int index) -> ::BuildConfig*;
  auto
      mutable_installed_build_config() -> ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BuildConfig >*;
  private:
  auto _internal_installed_build_config(int index) const -> const ::BuildConfig&;
  auto _internal_add_installed_build_config() -> ::BuildConfig*;
  public:
  auto installed_build_config(int index) const -> const ::BuildConfig&;
  auto add_installed_build_config() -> ::BuildConfig*;
  auto
      installed_build_config() const -> const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BuildConfig >&;

  // repeated .BuildConfig background_download_build_config = 9;
  auto background_download_build_config_size() const -> int;
  private:
  auto _internal_background_download_build_config_size() const -> int;
  public:
  void clear_background_download_build_config();
  auto mutable_background_download_build_config(int index) -> ::BuildConfig*;
  auto
      mutable_background_download_build_config() -> ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BuildConfig >*;
  private:
  auto _internal_background_download_build_config(int index) const -> const ::BuildConfig&;
  auto _internal_add_background_download_build_config() -> ::BuildConfig*;
  public:
  auto background_download_build_config(int index) const -> const ::BuildConfig&;
  auto add_background_download_build_config() -> ::BuildConfig*;
  auto
      background_download_build_config() const -> const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BuildConfig >&;

  // repeated string completed_install_actions = 11;
  auto completed_install_actions_size() const -> int;
  private:
  auto _internal_completed_install_actions_size() const -> int;
  public:
  void clear_completed_install_actions();
  auto completed_install_actions(int index) const -> const std::string&;
  auto mutable_completed_install_actions(int index) -> std::string*;
  void set_completed_install_actions(int index, const std::string& value);
  void set_completed_install_actions(int index, std::string&& value);
  void set_completed_install_actions(int index, const char* value);
  void set_completed_install_actions(int index, const char* value, size_t size);
  auto add_completed_install_actions() -> std::string*;
  void add_completed_install_actions(const std::string& value);
  void add_completed_install_actions(std::string&& value);
  void add_completed_install_actions(const char* value);
  void add_completed_install_actions(const char* value, size_t size);
  auto completed_install_actions() const -> const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&;
  auto mutable_completed_install_actions() -> ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*;
  private:
  auto _internal_completed_install_actions(int index) const -> const std::string&;
  auto _internal_add_completed_install_actions() -> std::string*;
  public:

  // string current_version = 6;
  void clear_current_version();
  auto current_version() const -> const std::string&;
  void set_current_version(const std::string& value);
  void set_current_version(std::string&& value);
  void set_current_version(const char* value);
  void set_current_version(const char* value, size_t size);
  auto mutable_current_version() -> std::string*;
  auto release_current_version() -> std::string*;
  void set_allocated_current_version(std::string* current_version);
  private:
  auto _internal_current_version() const -> const std::string&;
  void _internal_set_current_version(const std::string& value);
  auto _internal_mutable_current_version() -> std::string*;
  public:

  // string current_version_str = 7;
  void clear_current_version_str();
  auto current_version_str() const -> const std::string&;
  void set_current_version_str(const std::string& value);
  void set_current_version_str(std::string&& value);
  void set_current_version_str(const char* value);
  void set_current_version_str(const char* value, size_t size);
  auto mutable_current_version_str() -> std::string*;
  auto release_current_version_str() -> std::string*;
  void set_allocated_current_version_str(std::string* current_version_str);
  private:
  auto _internal_current_version_str() const -> const std::string&;
  void _internal_set_current_version_str(const std::string& value);
  auto _internal_mutable_current_version_str() -> std::string*;
  public:

  // string decryption_key = 10;
  void clear_decryption_key();
  auto decryption_key() const -> const std::string&;
  void set_decryption_key(const std::string& value);
  void set_decryption_key(std::string&& value);
  void set_decryption_key(const char* value);
  void set_decryption_key(const char* value, size_t size);
  auto mutable_decryption_key() -> std::string*;
  auto release_decryption_key() -> std::string*;
  void set_allocated_decryption_key(std::string* decryption_key);
  private:
  auto _internal_decryption_key() const -> const std::string&;
  void _internal_set_decryption_key(const std::string& value);
  auto _internal_mutable_decryption_key() -> std::string*;
  public:

  // bool installed = 1;
  void clear_installed();
  auto installed() const -> bool;
  void set_installed(bool value);
  private:
  auto _internal_installed() const -> bool;
  void _internal_set_installed(bool value);
  public:

  // bool playable = 2;
  void clear_playable();
  auto playable() const -> bool;
  void set_playable(bool value);
  private:
  auto _internal_playable() const -> bool;
  void _internal_set_playable(bool value);
  public:

  // bool update_complete = 3;
  void clear_update_complete();
  auto update_complete() const -> bool;
  void set_update_complete(bool value);
  private:
  auto _internal_update_complete() const -> bool;
  void _internal_set_update_complete(bool value);
  public:

  // bool background_download_available = 4;
  void clear_background_download_available();
  auto background_download_available() const -> bool;
  void set_background_download_available(bool value);
  private:
  auto _internal_background_download_available() const -> bool;
  void _internal_set_background_download_available(bool value);
  public:

  // bool background_download_complete = 5;
  void clear_background_download_complete();
  auto background_download_complete() const -> bool;
  void set_background_download_complete(bool value);
  private:
  auto _internal_background_download_complete() const -> bool;
  void _internal_set_background_download_complete(bool value);
  public:

  // @@protoc_insertion_point(class_scope:BaseProductState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BuildConfig > installed_build_config_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BuildConfig > background_download_build_config_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> completed_install_actions_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr current_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr current_version_str_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr decryption_key_;
  bool installed_;
  bool playable_;
  bool update_complete_;
  bool background_download_available_;
  bool background_download_complete_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class BackfillProgress PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BackfillProgress) */ {
 public:
  inline BackfillProgress() : BackfillProgress(nullptr) {}
  ~BackfillProgress() override;

  BackfillProgress(const BackfillProgress& from);
  BackfillProgress(BackfillProgress&& from) noexcept
    : BackfillProgress() {
    *this = ::std::move(from);
  }

  inline auto operator=(const BackfillProgress& from) -> BackfillProgress& {
    CopyFrom(from);
    return *this;
  }
  inline auto operator=(BackfillProgress&& from) noexcept -> BackfillProgress& {
    if (GetArena() == from.GetArena()) {
      if (this != &from) { InternalSwap(&from);
}
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static auto descriptor() -> const ::PROTOBUF_NAMESPACE_ID::Descriptor* {
    return GetDescriptor();
  }
  static auto GetDescriptor() -> const ::PROTOBUF_NAMESPACE_ID::Descriptor* {
    return GetMetadataStatic().descriptor;
  }
  static auto GetReflection() -> const ::PROTOBUF_NAMESPACE_ID::Reflection* {
    return GetMetadataStatic().reflection;
  }
  static auto default_instance() -> const BackfillProgress&;

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline auto internal_default_instance() -> const BackfillProgress* {
    return reinterpret_cast<const BackfillProgress*>(
               &_BackfillProgress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BackfillProgress& a, BackfillProgress& b) {
    a.Swap(&b);
  }
  inline void Swap(BackfillProgress* other) {
    if (other == this) { return;
}
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BackfillProgress* other) {
    if (other == this) { return;
}
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline auto New() const -> BackfillProgress* final {
    return CreateMaybeMessage<BackfillProgress>(nullptr);
  }

  auto New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const -> BackfillProgress* final {
    return CreateMaybeMessage<BackfillProgress>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BackfillProgress& from);
  void MergeFrom(const BackfillProgress& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  auto IsInitialized() const -> bool final;

  auto ByteSizeLong() const -> size_t final;
  auto _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) -> const char* final;
  auto _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const -> ::PROTOBUF_NAMESPACE_ID::uint8* final;
  auto GetCachedSize() const -> int final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BackfillProgress* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static auto FullMessageName() -> ::PROTOBUF_NAMESPACE_ID::StringPiece {
    return "BackfillProgress";
  }
  protected:
  explicit BackfillProgress(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  auto GetMetadata() const -> ::PROTOBUF_NAMESPACE_ID::Metadata final;
  private:
  static auto GetMetadataStatic() -> ::PROTOBUF_NAMESPACE_ID::Metadata {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schema_2eproto);
    return ::descriptor_table_schema_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProgressFieldNumber = 1,
    kDownloadLimitFieldNumber = 4,
    kBackgrounddownloadFieldNumber = 2,
    kPausedFieldNumber = 3,
  };
  // double progress = 1;
  void clear_progress();
  auto progress() const -> double;
  void set_progress(double value);
  private:
  auto _internal_progress() const -> double;
  void _internal_set_progress(double value);
  public:

  // uint64 download_limit = 4;
  void clear_download_limit();
  auto download_limit() const -> ::PROTOBUF_NAMESPACE_ID::uint64;
  void set_download_limit(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  auto _internal_download_limit() const -> ::PROTOBUF_NAMESPACE_ID::uint64;
  void _internal_set_download_limit(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // bool backgrounddownload = 2;
  void clear_backgrounddownload();
  auto backgrounddownload() const -> bool;
  void set_backgrounddownload(bool value);
  private:
  auto _internal_backgrounddownload() const -> bool;
  void _internal_set_backgrounddownload(bool value);
  public:

  // bool paused = 3;
  void clear_paused();
  auto paused() const -> bool;
  void set_paused(bool value);
  private:
  auto _internal_paused() const -> bool;
  void _internal_set_paused(bool value);
  public:

  // @@protoc_insertion_point(class_scope:BackfillProgress)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  double progress_;
  ::PROTOBUF_NAMESPACE_ID::uint64 download_limit_;
  bool backgrounddownload_;
  bool paused_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class RepairProgress PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RepairProgress) */ {
 public:
  inline RepairProgress() : RepairProgress(nullptr) {}
  ~RepairProgress() override;

  RepairProgress(const RepairProgress& from);
  RepairProgress(RepairProgress&& from) noexcept
    : RepairProgress() {
    *this = ::std::move(from);
  }

  inline auto operator=(const RepairProgress& from) -> RepairProgress& {
    CopyFrom(from);
    return *this;
  }
  inline auto operator=(RepairProgress&& from) noexcept -> RepairProgress& {
    if (GetArena() == from.GetArena()) {
      if (this != &from) { InternalSwap(&from);
}
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static auto descriptor() -> const ::PROTOBUF_NAMESPACE_ID::Descriptor* {
    return GetDescriptor();
  }
  static auto GetDescriptor() -> const ::PROTOBUF_NAMESPACE_ID::Descriptor* {
    return GetMetadataStatic().descriptor;
  }
  static auto GetReflection() -> const ::PROTOBUF_NAMESPACE_ID::Reflection* {
    return GetMetadataStatic().reflection;
  }
  static auto default_instance() -> const RepairProgress&;

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline auto internal_default_instance() -> const RepairProgress* {
    return reinterpret_cast<const RepairProgress*>(
               &_RepairProgress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RepairProgress& a, RepairProgress& b) {
    a.Swap(&b);
  }
  inline void Swap(RepairProgress* other) {
    if (other == this) { return;
}
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepairProgress* other) {
    if (other == this) { return;
}
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline auto New() const -> RepairProgress* final {
    return CreateMaybeMessage<RepairProgress>(nullptr);
  }

  auto New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const -> RepairProgress* final {
    return CreateMaybeMessage<RepairProgress>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RepairProgress& from);
  void MergeFrom(const RepairProgress& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  auto IsInitialized() const -> bool final;

  auto ByteSizeLong() const -> size_t final;
  auto _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) -> const char* final;
  auto _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const -> ::PROTOBUF_NAMESPACE_ID::uint8* final;
  auto GetCachedSize() const -> int final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RepairProgress* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static auto FullMessageName() -> ::PROTOBUF_NAMESPACE_ID::StringPiece {
    return "RepairProgress";
  }
  protected:
  explicit RepairProgress(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  auto GetMetadata() const -> ::PROTOBUF_NAMESPACE_ID::Metadata final;
  private:
  static auto GetMetadataStatic() -> ::PROTOBUF_NAMESPACE_ID::Metadata {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schema_2eproto);
    return ::descriptor_table_schema_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProgressFieldNumber = 1,
  };
  // double progress = 1;
  void clear_progress();
  auto progress() const -> double;
  void set_progress(double value);
  private:
  auto _internal_progress() const -> double;
  void _internal_set_progress(double value);
  public:

  // @@protoc_insertion_point(class_scope:RepairProgress)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  double progress_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class UpdateProgress PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UpdateProgress) */ {
 public:
  inline UpdateProgress() : UpdateProgress(nullptr) {}
  ~UpdateProgress() override;

  UpdateProgress(const UpdateProgress& from);
  UpdateProgress(UpdateProgress&& from) noexcept
    : UpdateProgress() {
    *this = ::std::move(from);
  }

  inline auto operator=(const UpdateProgress& from) -> UpdateProgress& {
    CopyFrom(from);
    return *this;
  }
  inline auto operator=(UpdateProgress&& from) noexcept -> UpdateProgress& {
    if (GetArena() == from.GetArena()) {
      if (this != &from) { InternalSwap(&from);
}
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static auto descriptor() -> const ::PROTOBUF_NAMESPACE_ID::Descriptor* {
    return GetDescriptor();
  }
  static auto GetDescriptor() -> const ::PROTOBUF_NAMESPACE_ID::Descriptor* {
    return GetMetadataStatic().descriptor;
  }
  static auto GetReflection() -> const ::PROTOBUF_NAMESPACE_ID::Reflection* {
    return GetMetadataStatic().reflection;
  }
  static auto default_instance() -> const UpdateProgress&;

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline auto internal_default_instance() -> const UpdateProgress* {
    return reinterpret_cast<const UpdateProgress*>(
               &_UpdateProgress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UpdateProgress& a, UpdateProgress& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateProgress* other) {
    if (other == this) { return;
}
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateProgress* other) {
    if (other == this) { return;
}
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline auto New() const -> UpdateProgress* final {
    return CreateMaybeMessage<UpdateProgress>(nullptr);
  }

  auto New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const -> UpdateProgress* final {
    return CreateMaybeMessage<UpdateProgress>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UpdateProgress& from);
  void MergeFrom(const UpdateProgress& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  auto IsInitialized() const -> bool final;

  auto ByteSizeLong() const -> size_t final;
  auto _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) -> const char* final;
  auto _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const -> ::PROTOBUF_NAMESPACE_ID::uint8* final;
  auto GetCachedSize() const -> int final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateProgress* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static auto FullMessageName() -> ::PROTOBUF_NAMESPACE_ID::StringPiece {
    return "UpdateProgress";
  }
  protected:
  explicit UpdateProgress(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  auto GetMetadata() const -> ::PROTOBUF_NAMESPACE_ID::Metadata final;
  private:
  static auto GetMetadataStatic() -> ::PROTOBUF_NAMESPACE_ID::Metadata {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schema_2eproto);
    return ::descriptor_table_schema_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLastDiscSetUsedFieldNumber = 1,
    kProgressFieldNumber = 2,
    kTotalToDownloadFieldNumber = 4,
    kDownloadRemainingFieldNumber = 5,
    kDiscIgnoredFieldNumber = 3,
  };
  // string last_disc_set_used = 1;
  void clear_last_disc_set_used();
  auto last_disc_set_used() const -> const std::string&;
  void set_last_disc_set_used(const std::string& value);
  void set_last_disc_set_used(std::string&& value);
  void set_last_disc_set_used(const char* value);
  void set_last_disc_set_used(const char* value, size_t size);
  auto mutable_last_disc_set_used() -> std::string*;
  auto release_last_disc_set_used() -> std::string*;
  void set_allocated_last_disc_set_used(std::string* last_disc_set_used);
  private:
  auto _internal_last_disc_set_used() const -> const std::string&;
  void _internal_set_last_disc_set_used(const std::string& value);
  auto _internal_mutable_last_disc_set_used() -> std::string*;
  public:

  // double progress = 2;
  void clear_progress();
  auto progress() const -> double;
  void set_progress(double value);
  private:
  auto _internal_progress() const -> double;
  void _internal_set_progress(double value);
  public:

  // uint64 total_to_download = 4;
  void clear_total_to_download();
  auto total_to_download() const -> ::PROTOBUF_NAMESPACE_ID::uint64;
  void set_total_to_download(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  auto _internal_total_to_download() const -> ::PROTOBUF_NAMESPACE_ID::uint64;
  void _internal_set_total_to_download(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 download_remaining = 5;
  void clear_download_remaining();
  auto download_remaining() const -> ::PROTOBUF_NAMESPACE_ID::uint64;
  void set_download_remaining(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  auto _internal_download_remaining() const -> ::PROTOBUF_NAMESPACE_ID::uint64;
  void _internal_set_download_remaining(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // bool disc_ignored = 3;
  void clear_disc_ignored();
  auto disc_ignored() const -> bool;
  void set_disc_ignored(bool value);
  private:
  auto _internal_disc_ignored() const -> bool;
  void _internal_set_disc_ignored(bool value);
  public:

  // @@protoc_insertion_point(class_scope:UpdateProgress)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_disc_set_used_;
  double progress_;
  ::PROTOBUF_NAMESPACE_ID::uint64 total_to_download_;
  ::PROTOBUF_NAMESPACE_ID::uint64 download_remaining_;
  bool disc_ignored_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class CachedProductState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CachedProductState) */ {
 public:
  inline CachedProductState() : CachedProductState(nullptr) {}
  ~CachedProductState() override;

  CachedProductState(const CachedProductState& from);
  CachedProductState(CachedProductState&& from) noexcept
    : CachedProductState() {
    *this = ::std::move(from);
  }

  inline auto operator=(const CachedProductState& from) -> CachedProductState& {
    CopyFrom(from);
    return *this;
  }
  inline auto operator=(CachedProductState&& from) noexcept -> CachedProductState& {
    if (GetArena() == from.GetArena()) {
      if (this != &from) { InternalSwap(&from);
}
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static auto descriptor() -> const ::PROTOBUF_NAMESPACE_ID::Descriptor* {
    return GetDescriptor();
  }
  static auto GetDescriptor() -> const ::PROTOBUF_NAMESPACE_ID::Descriptor* {
    return GetMetadataStatic().descriptor;
  }
  static auto GetReflection() -> const ::PROTOBUF_NAMESPACE_ID::Reflection* {
    return GetMetadataStatic().reflection;
  }
  static auto default_instance() -> const CachedProductState&;

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline auto internal_default_instance() -> const CachedProductState* {
    return reinterpret_cast<const CachedProductState*>(
               &_CachedProductState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CachedProductState& a, CachedProductState& b) {
    a.Swap(&b);
  }
  inline void Swap(CachedProductState* other) {
    if (other == this) { return;
}
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CachedProductState* other) {
    if (other == this) { return;
}
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline auto New() const -> CachedProductState* final {
    return CreateMaybeMessage<CachedProductState>(nullptr);
  }

  auto New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const -> CachedProductState* final {
    return CreateMaybeMessage<CachedProductState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CachedProductState& from);
  void MergeFrom(const CachedProductState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  auto IsInitialized() const -> bool final;

  auto ByteSizeLong() const -> size_t final;
  auto _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) -> const char* final;
  auto _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const -> ::PROTOBUF_NAMESPACE_ID::uint8* final;
  auto GetCachedSize() const -> int final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CachedProductState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static auto FullMessageName() -> ::PROTOBUF_NAMESPACE_ID::StringPiece {
    return "CachedProductState";
  }
  protected:
  explicit CachedProductState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  auto GetMetadata() const -> ::PROTOBUF_NAMESPACE_ID::Metadata final;
  private:
  static auto GetMetadataStatic() -> ::PROTOBUF_NAMESPACE_ID::Metadata {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schema_2eproto);
    return ::descriptor_table_schema_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBaseProductStateFieldNumber = 1,
    kBackfillProgressFieldNumber = 2,
    kRepairProgressFieldNumber = 3,
    kUpdateProgressFieldNumber = 4,
  };
  // .BaseProductState base_product_state = 1;
  auto has_base_product_state() const -> bool;
  private:
  auto _internal_has_base_product_state() const -> bool;
  public:
  void clear_base_product_state();
  auto base_product_state() const -> const ::BaseProductState&;
  auto release_base_product_state() -> ::BaseProductState*;
  auto mutable_base_product_state() -> ::BaseProductState*;
  void set_allocated_base_product_state(::BaseProductState* base_product_state);
  private:
  auto _internal_base_product_state() const -> const ::BaseProductState&;
  auto _internal_mutable_base_product_state() -> ::BaseProductState*;
  public:
  void unsafe_arena_set_allocated_base_product_state(
      ::BaseProductState* base_product_state);
  auto unsafe_arena_release_base_product_state() -> ::BaseProductState*;

  // .BackfillProgress backfill_progress = 2;
  auto has_backfill_progress() const -> bool;
  private:
  auto _internal_has_backfill_progress() const -> bool;
  public:
  void clear_backfill_progress();
  auto backfill_progress() const -> const ::BackfillProgress&;
  auto release_backfill_progress() -> ::BackfillProgress*;
  auto mutable_backfill_progress() -> ::BackfillProgress*;
  void set_allocated_backfill_progress(::BackfillProgress* backfill_progress);
  private:
  auto _internal_backfill_progress() const -> const ::BackfillProgress&;
  auto _internal_mutable_backfill_progress() -> ::BackfillProgress*;
  public:
  void unsafe_arena_set_allocated_backfill_progress(
      ::BackfillProgress* backfill_progress);
  auto unsafe_arena_release_backfill_progress() -> ::BackfillProgress*;

  // .RepairProgress repair_progress = 3;
  auto has_repair_progress() const -> bool;
  private:
  auto _internal_has_repair_progress() const -> bool;
  public:
  void clear_repair_progress();
  auto repair_progress() const -> const ::RepairProgress&;
  auto release_repair_progress() -> ::RepairProgress*;
  auto mutable_repair_progress() -> ::RepairProgress*;
  void set_allocated_repair_progress(::RepairProgress* repair_progress);
  private:
  auto _internal_repair_progress() const -> const ::RepairProgress&;
  auto _internal_mutable_repair_progress() -> ::RepairProgress*;
  public:
  void unsafe_arena_set_allocated_repair_progress(
      ::RepairProgress* repair_progress);
  auto unsafe_arena_release_repair_progress() -> ::RepairProgress*;

  // .UpdateProgress update_progress = 4;
  auto has_update_progress() const -> bool;
  private:
  auto _internal_has_update_progress() const -> bool;
  public:
  void clear_update_progress();
  auto update_progress() const -> const ::UpdateProgress&;
  auto release_update_progress() -> ::UpdateProgress*;
  auto mutable_update_progress() -> ::UpdateProgress*;
  void set_allocated_update_progress(::UpdateProgress* update_progress);
  private:
  auto _internal_update_progress() const -> const ::UpdateProgress&;
  auto _internal_mutable_update_progress() -> ::UpdateProgress*;
  public:
  void unsafe_arena_set_allocated_update_progress(
      ::UpdateProgress* update_progress);
  auto unsafe_arena_release_update_progress() -> ::UpdateProgress*;

  // @@protoc_insertion_point(class_scope:CachedProductState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  ::BaseProductState* base_product_state_;
  ::BackfillProgress* backfill_progress_;
  ::RepairProgress* repair_progress_;
  ::UpdateProgress* update_progress_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class ProductOperations PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProductOperations) */ {
 public:
  inline ProductOperations() : ProductOperations(nullptr) {}
  ~ProductOperations() override;

  ProductOperations(const ProductOperations& from);
  ProductOperations(ProductOperations&& from) noexcept
    : ProductOperations() {
    *this = ::std::move(from);
  }

  inline auto operator=(const ProductOperations& from) -> ProductOperations& {
    CopyFrom(from);
    return *this;
  }
  inline auto operator=(ProductOperations&& from) noexcept -> ProductOperations& {
    if (GetArena() == from.GetArena()) {
      if (this != &from) { InternalSwap(&from);
}
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static auto descriptor() -> const ::PROTOBUF_NAMESPACE_ID::Descriptor* {
    return GetDescriptor();
  }
  static auto GetDescriptor() -> const ::PROTOBUF_NAMESPACE_ID::Descriptor* {
    return GetMetadataStatic().descriptor;
  }
  static auto GetReflection() -> const ::PROTOBUF_NAMESPACE_ID::Reflection* {
    return GetMetadataStatic().reflection;
  }
  static auto default_instance() -> const ProductOperations&;

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline auto internal_default_instance() -> const ProductOperations* {
    return reinterpret_cast<const ProductOperations*>(
               &_ProductOperations_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ProductOperations& a, ProductOperations& b) {
    a.Swap(&b);
  }
  inline void Swap(ProductOperations* other) {
    if (other == this) { return;
}
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProductOperations* other) {
    if (other == this) { return;
}
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline auto New() const -> ProductOperations* final {
    return CreateMaybeMessage<ProductOperations>(nullptr);
  }

  auto New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const -> ProductOperations* final {
    return CreateMaybeMessage<ProductOperations>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ProductOperations& from);
  void MergeFrom(const ProductOperations& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  auto IsInitialized() const -> bool final;

  auto ByteSizeLong() const -> size_t final;
  auto _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) -> const char* final;
  auto _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const -> ::PROTOBUF_NAMESPACE_ID::uint8* final;
  auto GetCachedSize() const -> int final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProductOperations* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static auto FullMessageName() -> ::PROTOBUF_NAMESPACE_ID::StringPiece {
    return "ProductOperations";
  }
  protected:
  explicit ProductOperations(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  auto GetMetadata() const -> ::PROTOBUF_NAMESPACE_ID::Metadata final;
  private:
  static auto GetMetadataStatic() -> ::PROTOBUF_NAMESPACE_ID::Metadata {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schema_2eproto);
    return ::descriptor_table_schema_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPriorityFieldNumber = 2,
    kActiveOperationFieldNumber = 1,
  };
  // uint64 priority = 2;
  void clear_priority();
  auto priority() const -> ::PROTOBUF_NAMESPACE_ID::uint64;
  void set_priority(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  auto _internal_priority() const -> ::PROTOBUF_NAMESPACE_ID::uint64;
  void _internal_set_priority(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .Operation active_operation = 1;
  void clear_active_operation();
  auto active_operation() const -> ::Operation;
  void set_active_operation(::Operation value);
  private:
  auto _internal_active_operation() const -> ::Operation;
  void _internal_set_active_operation(::Operation value);
  public:

  // @@protoc_insertion_point(class_scope:ProductOperations)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  ::PROTOBUF_NAMESPACE_ID::uint64 priority_;
  int active_operation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class ProductInstall PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProductInstall) */ {
 public:
  inline ProductInstall() : ProductInstall(nullptr) {}
  ~ProductInstall() override;

  ProductInstall(const ProductInstall& from);
  ProductInstall(ProductInstall&& from) noexcept
    : ProductInstall() {
    *this = ::std::move(from);
  }

  inline auto operator=(const ProductInstall& from) -> ProductInstall& {
    CopyFrom(from);
    return *this;
  }
  inline auto operator=(ProductInstall&& from) noexcept -> ProductInstall& {
    if (GetArena() == from.GetArena()) {
      if (this != &from) { InternalSwap(&from);
}
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static auto descriptor() -> const ::PROTOBUF_NAMESPACE_ID::Descriptor* {
    return GetDescriptor();
  }
  static auto GetDescriptor() -> const ::PROTOBUF_NAMESPACE_ID::Descriptor* {
    return GetMetadataStatic().descriptor;
  }
  static auto GetReflection() -> const ::PROTOBUF_NAMESPACE_ID::Reflection* {
    return GetMetadataStatic().reflection;
  }
  static auto default_instance() -> const ProductInstall&;

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline auto internal_default_instance() -> const ProductInstall* {
    return reinterpret_cast<const ProductInstall*>(
               &_ProductInstall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ProductInstall& a, ProductInstall& b) {
    a.Swap(&b);
  }
  inline void Swap(ProductInstall* other) {
    if (other == this) { return;
}
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProductInstall* other) {
    if (other == this) { return;
}
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline auto New() const -> ProductInstall* final {
    return CreateMaybeMessage<ProductInstall>(nullptr);
  }

  auto New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const -> ProductInstall* final {
    return CreateMaybeMessage<ProductInstall>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ProductInstall& from);
  void MergeFrom(const ProductInstall& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  auto IsInitialized() const -> bool final;

  auto ByteSizeLong() const -> size_t final;
  auto _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) -> const char* final;
  auto _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const -> ::PROTOBUF_NAMESPACE_ID::uint8* final;
  auto GetCachedSize() const -> int final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProductInstall* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static auto FullMessageName() -> ::PROTOBUF_NAMESPACE_ID::StringPiece {
    return "ProductInstall";
  }
  protected:
  explicit ProductInstall(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  auto GetMetadata() const -> ::PROTOBUF_NAMESPACE_ID::Metadata final;
  private:
  static auto GetMetadataStatic() -> ::PROTOBUF_NAMESPACE_ID::Metadata {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schema_2eproto);
    return ::descriptor_table_schema_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
    kProductCodeFieldNumber = 2,
    kSettingsFieldNumber = 3,
    kCachedProductStateFieldNumber = 4,
    kProductOperationsFieldNumber = 5,
  };
  // string uid = 1;
  void clear_uid();
  auto uid() const -> const std::string&;
  void set_uid(const std::string& value);
  void set_uid(std::string&& value);
  void set_uid(const char* value);
  void set_uid(const char* value, size_t size);
  auto mutable_uid() -> std::string*;
  auto release_uid() -> std::string*;
  void set_allocated_uid(std::string* uid);
  private:
  auto _internal_uid() const -> const std::string&;
  void _internal_set_uid(const std::string& value);
  auto _internal_mutable_uid() -> std::string*;
  public:

  // string product_code = 2;
  void clear_product_code();
  auto product_code() const -> const std::string&;
  void set_product_code(const std::string& value);
  void set_product_code(std::string&& value);
  void set_product_code(const char* value);
  void set_product_code(const char* value, size_t size);
  auto mutable_product_code() -> std::string*;
  auto release_product_code() -> std::string*;
  void set_allocated_product_code(std::string* product_code);
  private:
  auto _internal_product_code() const -> const std::string&;
  void _internal_set_product_code(const std::string& value);
  auto _internal_mutable_product_code() -> std::string*;
  public:

  // .UserSettings settings = 3;
  auto has_settings() const -> bool;
  private:
  auto _internal_has_settings() const -> bool;
  public:
  void clear_settings();
  auto settings() const -> const ::UserSettings&;
  auto release_settings() -> ::UserSettings*;
  auto mutable_settings() -> ::UserSettings*;
  void set_allocated_settings(::UserSettings* settings);
  private:
  auto _internal_settings() const -> const ::UserSettings&;
  auto _internal_mutable_settings() -> ::UserSettings*;
  public:
  void unsafe_arena_set_allocated_settings(
      ::UserSettings* settings);
  auto unsafe_arena_release_settings() -> ::UserSettings*;

  // .CachedProductState cached_product_state = 4;
  auto has_cached_product_state() const -> bool;
  private:
  auto _internal_has_cached_product_state() const -> bool;
  public:
  void clear_cached_product_state();
  auto cached_product_state() const -> const ::CachedProductState&;
  auto release_cached_product_state() -> ::CachedProductState*;
  auto mutable_cached_product_state() -> ::CachedProductState*;
  void set_allocated_cached_product_state(::CachedProductState* cached_product_state);
  private:
  auto _internal_cached_product_state() const -> const ::CachedProductState&;
  auto _internal_mutable_cached_product_state() -> ::CachedProductState*;
  public:
  void unsafe_arena_set_allocated_cached_product_state(
      ::CachedProductState* cached_product_state);
  auto unsafe_arena_release_cached_product_state() -> ::CachedProductState*;

  // .ProductOperations product_operations = 5;
  auto has_product_operations() const -> bool;
  private:
  auto _internal_has_product_operations() const -> bool;
  public:
  void clear_product_operations();
  auto product_operations() const -> const ::ProductOperations&;
  auto release_product_operations() -> ::ProductOperations*;
  auto mutable_product_operations() -> ::ProductOperations*;
  void set_allocated_product_operations(::ProductOperations* product_operations);
  private:
  auto _internal_product_operations() const -> const ::ProductOperations&;
  auto _internal_mutable_product_operations() -> ::ProductOperations*;
  public:
  void unsafe_arena_set_allocated_product_operations(
      ::ProductOperations* product_operations);
  auto unsafe_arena_release_product_operations() -> ::ProductOperations*;

  // @@protoc_insertion_point(class_scope:ProductInstall)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr product_code_;
  ::UserSettings* settings_;
  ::CachedProductState* cached_product_state_;
  ::ProductOperations* product_operations_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class ProductConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProductConfig) */ {
 public:
  inline ProductConfig() : ProductConfig(nullptr) {}
  ~ProductConfig() override;

  ProductConfig(const ProductConfig& from);
  ProductConfig(ProductConfig&& from) noexcept
    : ProductConfig() {
    *this = ::std::move(from);
  }

  inline auto operator=(const ProductConfig& from) -> ProductConfig& {
    CopyFrom(from);
    return *this;
  }
  inline auto operator=(ProductConfig&& from) noexcept -> ProductConfig& {
    if (GetArena() == from.GetArena()) {
      if (this != &from) { InternalSwap(&from);
}
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static auto descriptor() -> const ::PROTOBUF_NAMESPACE_ID::Descriptor* {
    return GetDescriptor();
  }
  static auto GetDescriptor() -> const ::PROTOBUF_NAMESPACE_ID::Descriptor* {
    return GetMetadataStatic().descriptor;
  }
  static auto GetReflection() -> const ::PROTOBUF_NAMESPACE_ID::Reflection* {
    return GetMetadataStatic().reflection;
  }
  static auto default_instance() -> const ProductConfig&;

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline auto internal_default_instance() -> const ProductConfig* {
    return reinterpret_cast<const ProductConfig*>(
               &_ProductConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ProductConfig& a, ProductConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ProductConfig* other) {
    if (other == this) { return;
}
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProductConfig* other) {
    if (other == this) { return;
}
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline auto New() const -> ProductConfig* final {
    return CreateMaybeMessage<ProductConfig>(nullptr);
  }

  auto New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const -> ProductConfig* final {
    return CreateMaybeMessage<ProductConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ProductConfig& from);
  void MergeFrom(const ProductConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  auto IsInitialized() const -> bool final;

  auto ByteSizeLong() const -> size_t final;
  auto _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) -> const char* final;
  auto _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const -> ::PROTOBUF_NAMESPACE_ID::uint8* final;
  auto GetCachedSize() const -> int final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProductConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static auto FullMessageName() -> ::PROTOBUF_NAMESPACE_ID::StringPiece {
    return "ProductConfig";
  }
  protected:
  explicit ProductConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  auto GetMetadata() const -> ::PROTOBUF_NAMESPACE_ID::Metadata final;
  private:
  static auto GetMetadataStatic() -> ::PROTOBUF_NAMESPACE_ID::Metadata {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schema_2eproto);
    return ::descriptor_table_schema_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProductCodeFieldNumber = 1,
    kMetadataHashFieldNumber = 2,
    kTimestampFieldNumber = 3,
  };
  // string product_code = 1;
  void clear_product_code();
  auto product_code() const -> const std::string&;
  void set_product_code(const std::string& value);
  void set_product_code(std::string&& value);
  void set_product_code(const char* value);
  void set_product_code(const char* value, size_t size);
  auto mutable_product_code() -> std::string*;
  auto release_product_code() -> std::string*;
  void set_allocated_product_code(std::string* product_code);
  private:
  auto _internal_product_code() const -> const std::string&;
  void _internal_set_product_code(const std::string& value);
  auto _internal_mutable_product_code() -> std::string*;
  public:

  // string metadata_hash = 2;
  void clear_metadata_hash();
  auto metadata_hash() const -> const std::string&;
  void set_metadata_hash(const std::string& value);
  void set_metadata_hash(std::string&& value);
  void set_metadata_hash(const char* value);
  void set_metadata_hash(const char* value, size_t size);
  auto mutable_metadata_hash() -> std::string*;
  auto release_metadata_hash() -> std::string*;
  void set_allocated_metadata_hash(std::string* metadata_hash);
  private:
  auto _internal_metadata_hash() const -> const std::string&;
  void _internal_set_metadata_hash(const std::string& value);
  auto _internal_mutable_metadata_hash() -> std::string*;
  public:

  // string timestamp = 3;
  void clear_timestamp();
  auto timestamp() const -> const std::string&;
  void set_timestamp(const std::string& value);
  void set_timestamp(std::string&& value);
  void set_timestamp(const char* value);
  void set_timestamp(const char* value, size_t size);
  auto mutable_timestamp() -> std::string*;
  auto release_timestamp() -> std::string*;
  void set_allocated_timestamp(std::string* timestamp);
  private:
  auto _internal_timestamp() const -> const std::string&;
  void _internal_set_timestamp(const std::string& value);
  auto _internal_mutable_timestamp() -> std::string*;
  public:

  // @@protoc_insertion_point(class_scope:ProductConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr product_code_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr metadata_hash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class ActiveProcess PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ActiveProcess) */ {
 public:
  inline ActiveProcess() : ActiveProcess(nullptr) {}
  ~ActiveProcess() override;

  ActiveProcess(const ActiveProcess& from);
  ActiveProcess(ActiveProcess&& from) noexcept
    : ActiveProcess() {
    *this = ::std::move(from);
  }

  inline auto operator=(const ActiveProcess& from) -> ActiveProcess& {
    CopyFrom(from);
    return *this;
  }
  inline auto operator=(ActiveProcess&& from) noexcept -> ActiveProcess& {
    if (GetArena() == from.GetArena()) {
      if (this != &from) { InternalSwap(&from);
}
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static auto descriptor() -> const ::PROTOBUF_NAMESPACE_ID::Descriptor* {
    return GetDescriptor();
  }
  static auto GetDescriptor() -> const ::PROTOBUF_NAMESPACE_ID::Descriptor* {
    return GetMetadataStatic().descriptor;
  }
  static auto GetReflection() -> const ::PROTOBUF_NAMESPACE_ID::Reflection* {
    return GetMetadataStatic().reflection;
  }
  static auto default_instance() -> const ActiveProcess&;

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline auto internal_default_instance() -> const ActiveProcess* {
    return reinterpret_cast<const ActiveProcess*>(
               &_ActiveProcess_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ActiveProcess& a, ActiveProcess& b) {
    a.Swap(&b);
  }
  inline void Swap(ActiveProcess* other) {
    if (other == this) { return;
}
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActiveProcess* other) {
    if (other == this) { return;
}
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline auto New() const -> ActiveProcess* final {
    return CreateMaybeMessage<ActiveProcess>(nullptr);
  }

  auto New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const -> ActiveProcess* final {
    return CreateMaybeMessage<ActiveProcess>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ActiveProcess& from);
  void MergeFrom(const ActiveProcess& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  auto IsInitialized() const -> bool final;

  auto ByteSizeLong() const -> size_t final;
  auto _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) -> const char* final;
  auto _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const -> ::PROTOBUF_NAMESPACE_ID::uint8* final;
  auto GetCachedSize() const -> int final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActiveProcess* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static auto FullMessageName() -> ::PROTOBUF_NAMESPACE_ID::StringPiece {
    return "ActiveProcess";
  }
  protected:
  explicit ActiveProcess(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  auto GetMetadata() const -> ::PROTOBUF_NAMESPACE_ID::Metadata final;
  private:
  static auto GetMetadataStatic() -> ::PROTOBUF_NAMESPACE_ID::Metadata {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schema_2eproto);
    return ::descriptor_table_schema_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 3,
    kProcessNameFieldNumber = 1,
    kPidFieldNumber = 2,
  };
  // repeated string uri = 3;
  auto uri_size() const -> int;
  private:
  auto _internal_uri_size() const -> int;
  public:
  void clear_uri();
  auto uri(int index) const -> const std::string&;
  auto mutable_uri(int index) -> std::string*;
  void set_uri(int index, const std::string& value);
  void set_uri(int index, std::string&& value);
  void set_uri(int index, const char* value);
  void set_uri(int index, const char* value, size_t size);
  auto add_uri() -> std::string*;
  void add_uri(const std::string& value);
  void add_uri(std::string&& value);
  void add_uri(const char* value);
  void add_uri(const char* value, size_t size);
  auto uri() const -> const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&;
  auto mutable_uri() -> ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*;
  private:
  auto _internal_uri(int index) const -> const std::string&;
  auto _internal_add_uri() -> std::string*;
  public:

  // string process_name = 1;
  void clear_process_name();
  auto process_name() const -> const std::string&;
  void set_process_name(const std::string& value);
  void set_process_name(std::string&& value);
  void set_process_name(const char* value);
  void set_process_name(const char* value, size_t size);
  auto mutable_process_name() -> std::string*;
  auto release_process_name() -> std::string*;
  void set_allocated_process_name(std::string* process_name);
  private:
  auto _internal_process_name() const -> const std::string&;
  void _internal_set_process_name(const std::string& value);
  auto _internal_mutable_process_name() -> std::string*;
  public:

  // int32 pid = 2;
  void clear_pid();
  auto pid() const -> ::PROTOBUF_NAMESPACE_ID::int32;
  void set_pid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  auto _internal_pid() const -> ::PROTOBUF_NAMESPACE_ID::int32;
  void _internal_set_pid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ActiveProcess)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> uri_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr process_name_;
  ::PROTOBUF_NAMESPACE_ID::int32 pid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class DownloadSettings PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DownloadSettings) */ {
 public:
  inline DownloadSettings() : DownloadSettings(nullptr) {}
  ~DownloadSettings() override;

  DownloadSettings(const DownloadSettings& from);
  DownloadSettings(DownloadSettings&& from) noexcept
    : DownloadSettings() {
    *this = ::std::move(from);
  }

  inline auto operator=(const DownloadSettings& from) -> DownloadSettings& {
    CopyFrom(from);
    return *this;
  }
  inline auto operator=(DownloadSettings&& from) noexcept -> DownloadSettings& {
    if (GetArena() == from.GetArena()) {
      if (this != &from) { InternalSwap(&from);
}
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static auto descriptor() -> const ::PROTOBUF_NAMESPACE_ID::Descriptor* {
    return GetDescriptor();
  }
  static auto GetDescriptor() -> const ::PROTOBUF_NAMESPACE_ID::Descriptor* {
    return GetMetadataStatic().descriptor;
  }
  static auto GetReflection() -> const ::PROTOBUF_NAMESPACE_ID::Reflection* {
    return GetMetadataStatic().reflection;
  }
  static auto default_instance() -> const DownloadSettings&;

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline auto internal_default_instance() -> const DownloadSettings* {
    return reinterpret_cast<const DownloadSettings*>(
               &_DownloadSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(DownloadSettings& a, DownloadSettings& b) {
    a.Swap(&b);
  }
  inline void Swap(DownloadSettings* other) {
    if (other == this) { return;
}
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DownloadSettings* other) {
    if (other == this) { return;
}
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline auto New() const -> DownloadSettings* final {
    return CreateMaybeMessage<DownloadSettings>(nullptr);
  }

  auto New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const -> DownloadSettings* final {
    return CreateMaybeMessage<DownloadSettings>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DownloadSettings& from);
  void MergeFrom(const DownloadSettings& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  auto IsInitialized() const -> bool final;

  auto ByteSizeLong() const -> size_t final;
  auto _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) -> const char* final;
  auto _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const -> ::PROTOBUF_NAMESPACE_ID::uint8* final;
  auto GetCachedSize() const -> int final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DownloadSettings* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static auto FullMessageName() -> ::PROTOBUF_NAMESPACE_ID::StringPiece {
    return "DownloadSettings";
  }
  protected:
  explicit DownloadSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  auto GetMetadata() const -> ::PROTOBUF_NAMESPACE_ID::Metadata final;
  private:
  static auto GetMetadataStatic() -> ::PROTOBUF_NAMESPACE_ID::Metadata {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schema_2eproto);
    return ::descriptor_table_schema_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDownloadLimitFieldNumber = 1,
    kBackfillLimitFieldNumber = 2,
  };
  // int32 download_limit = 1;
  void clear_download_limit();
  auto download_limit() const -> ::PROTOBUF_NAMESPACE_ID::int32;
  void set_download_limit(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  auto _internal_download_limit() const -> ::PROTOBUF_NAMESPACE_ID::int32;
  void _internal_set_download_limit(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 backfill_limit = 2;
  void clear_backfill_limit();
  auto backfill_limit() const -> ::PROTOBUF_NAMESPACE_ID::int32;
  void set_backfill_limit(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  auto _internal_backfill_limit() const -> ::PROTOBUF_NAMESPACE_ID::int32;
  void _internal_set_backfill_limit(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:DownloadSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  ::PROTOBUF_NAMESPACE_ID::int32 download_limit_;
  ::PROTOBUF_NAMESPACE_ID::int32 backfill_limit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class ProductDb PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProductDb) */ {
 public:
  inline ProductDb() : ProductDb(nullptr) {}
  ~ProductDb() override;

  ProductDb(const ProductDb& from);
  ProductDb(ProductDb&& from) noexcept
    : ProductDb() {
    *this = ::std::move(from);
  }

  inline auto operator=(const ProductDb& from) -> ProductDb& {
    CopyFrom(from);
    return *this;
  }
  inline auto operator=(ProductDb&& from) noexcept -> ProductDb& {
    if (GetArena() == from.GetArena()) {
      if (this != &from) { InternalSwap(&from);
}
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static auto descriptor() -> const ::PROTOBUF_NAMESPACE_ID::Descriptor* {
    return GetDescriptor();
  }
  static auto GetDescriptor() -> const ::PROTOBUF_NAMESPACE_ID::Descriptor* {
    return GetMetadataStatic().descriptor;
  }
  static auto GetReflection() -> const ::PROTOBUF_NAMESPACE_ID::Reflection* {
    return GetMetadataStatic().reflection;
  }
  static auto default_instance() -> const ProductDb&;

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline auto internal_default_instance() -> const ProductDb* {
    return reinterpret_cast<const ProductDb*>(
               &_ProductDb_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ProductDb& a, ProductDb& b) {
    a.Swap(&b);
  }
  inline void Swap(ProductDb* other) {
    if (other == this) { return;
}
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProductDb* other) {
    if (other == this) { return;
}
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline auto New() const -> ProductDb* final {
    return CreateMaybeMessage<ProductDb>(nullptr);
  }

  auto New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const -> ProductDb* final {
    return CreateMaybeMessage<ProductDb>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ProductDb& from);
  void MergeFrom(const ProductDb& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  auto IsInitialized() const -> bool final;

  auto ByteSizeLong() const -> size_t final;
  auto _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) -> const char* final;
  auto _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const -> ::PROTOBUF_NAMESPACE_ID::uint8* final;
  auto GetCachedSize() const -> int final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProductDb* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static auto FullMessageName() -> ::PROTOBUF_NAMESPACE_ID::StringPiece {
    return "ProductDb";
  }
  protected:
  explicit ProductDb(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  auto GetMetadata() const -> ::PROTOBUF_NAMESPACE_ID::Metadata final;
  private:
  static auto GetMetadataStatic() -> ::PROTOBUF_NAMESPACE_ID::Metadata {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schema_2eproto);
    return ::descriptor_table_schema_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProductInstallsFieldNumber = 1,
    kActiveInstallsFieldNumber = 2,
    kActiveProcessesFieldNumber = 3,
    kProductConfigsFieldNumber = 4,
    kDownloadSettingsFieldNumber = 5,
  };
  // repeated .ProductInstall product_installs = 1;
  auto product_installs_size() const -> int;
  private:
  auto _internal_product_installs_size() const -> int;
  public:
  void clear_product_installs();
  auto mutable_product_installs(int index) -> ::ProductInstall*;
  auto
      mutable_product_installs() -> ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProductInstall >*;
  private:
  auto _internal_product_installs(int index) const -> const ::ProductInstall&;
  auto _internal_add_product_installs() -> ::ProductInstall*;
  public:
  auto product_installs(int index) const -> const ::ProductInstall&;
  auto add_product_installs() -> ::ProductInstall*;
  auto
      product_installs() const -> const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProductInstall >&;

  // repeated .InstallHandshake active_installs = 2;
  auto active_installs_size() const -> int;
  private:
  auto _internal_active_installs_size() const -> int;
  public:
  void clear_active_installs();
  auto mutable_active_installs(int index) -> ::InstallHandshake*;
  auto
      mutable_active_installs() -> ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::InstallHandshake >*;
  private:
  auto _internal_active_installs(int index) const -> const ::InstallHandshake&;
  auto _internal_add_active_installs() -> ::InstallHandshake*;
  public:
  auto active_installs(int index) const -> const ::InstallHandshake&;
  auto add_active_installs() -> ::InstallHandshake*;
  auto
      active_installs() const -> const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::InstallHandshake >&;

  // repeated .ActiveProcess active_processes = 3;
  auto active_processes_size() const -> int;
  private:
  auto _internal_active_processes_size() const -> int;
  public:
  void clear_active_processes();
  auto mutable_active_processes(int index) -> ::ActiveProcess*;
  auto
      mutable_active_processes() -> ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ActiveProcess >*;
  private:
  auto _internal_active_processes(int index) const -> const ::ActiveProcess&;
  auto _internal_add_active_processes() -> ::ActiveProcess*;
  public:
  auto active_processes(int index) const -> const ::ActiveProcess&;
  auto add_active_processes() -> ::ActiveProcess*;
  auto
      active_processes() const -> const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ActiveProcess >&;

  // repeated .ProductConfig product_configs = 4;
  auto product_configs_size() const -> int;
  private:
  auto _internal_product_configs_size() const -> int;
  public:
  void clear_product_configs();
  auto mutable_product_configs(int index) -> ::ProductConfig*;
  auto
      mutable_product_configs() -> ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProductConfig >*;
  private:
  auto _internal_product_configs(int index) const -> const ::ProductConfig&;
  auto _internal_add_product_configs() -> ::ProductConfig*;
  public:
  auto product_configs(int index) const -> const ::ProductConfig&;
  auto add_product_configs() -> ::ProductConfig*;
  auto
      product_configs() const -> const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProductConfig >&;

  // .DownloadSettings download_settings = 5;
  auto has_download_settings() const -> bool;
  private:
  auto _internal_has_download_settings() const -> bool;
  public:
  void clear_download_settings();
  auto download_settings() const -> const ::DownloadSettings&;
  auto release_download_settings() -> ::DownloadSettings*;
  auto mutable_download_settings() -> ::DownloadSettings*;
  void set_allocated_download_settings(::DownloadSettings* download_settings);
  private:
  auto _internal_download_settings() const -> const ::DownloadSettings&;
  auto _internal_mutable_download_settings() -> ::DownloadSettings*;
  public:
  void unsafe_arena_set_allocated_download_settings(
      ::DownloadSettings* download_settings);
  auto unsafe_arena_release_download_settings() -> ::DownloadSettings*;

  // @@protoc_insertion_point(class_scope:ProductDb)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProductInstall > product_installs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::InstallHandshake > active_installs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ActiveProcess > active_processes_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProductConfig > product_configs_;
  ::DownloadSettings* download_settings_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schema_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LanguageSetting

// string language = 1;
inline void LanguageSetting::clear_language() {
  language_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto LanguageSetting::language() const -> const std::string& {
  // @@protoc_insertion_point(field_get:LanguageSetting.language)
  return _internal_language();
}
inline void LanguageSetting::set_language(const std::string& value) {
  _internal_set_language(value);
  // @@protoc_insertion_point(field_set:LanguageSetting.language)
}
inline auto LanguageSetting::mutable_language() -> std::string* {
  // @@protoc_insertion_point(field_mutable:LanguageSetting.language)
  return _internal_mutable_language();
}
inline auto LanguageSetting::_internal_language() const -> const std::string& {
  return language_.Get();
}
inline void LanguageSetting::_internal_set_language(const std::string& value) {
  
  language_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void LanguageSetting::set_language(std::string&& value) {
  
  language_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:LanguageSetting.language)
}
inline void LanguageSetting::set_language(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  language_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:LanguageSetting.language)
}
inline void LanguageSetting::set_language(const char* value,
    size_t size) {
  
  language_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:LanguageSetting.language)
}
inline auto LanguageSetting::_internal_mutable_language() -> std::string* {
  
  return language_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto LanguageSetting::release_language() -> std::string* {
  // @@protoc_insertion_point(field_release:LanguageSetting.language)
  return language_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LanguageSetting::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    
  } else {
    
  }
  language_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), language,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:LanguageSetting.language)
}

// .LanguageOption option = 2;
inline void LanguageSetting::clear_option() {
  option_ = 0;
}
inline auto LanguageSetting::_internal_option() const -> ::LanguageOption {
  return static_cast< ::LanguageOption >(option_);
}
inline auto LanguageSetting::option() const -> ::LanguageOption {
  // @@protoc_insertion_point(field_get:LanguageSetting.option)
  return _internal_option();
}
inline void LanguageSetting::_internal_set_option(::LanguageOption value) {
  
  option_ = value;
}
inline void LanguageSetting::set_option(::LanguageOption value) {
  _internal_set_option(value);
  // @@protoc_insertion_point(field_set:LanguageSetting.option)
}

// -------------------------------------------------------------------

// UserSettings

// string install_path = 1;
inline void UserSettings::clear_install_path() {
  install_path_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto UserSettings::install_path() const -> const std::string& {
  // @@protoc_insertion_point(field_get:UserSettings.install_path)
  return _internal_install_path();
}
inline void UserSettings::set_install_path(const std::string& value) {
  _internal_set_install_path(value);
  // @@protoc_insertion_point(field_set:UserSettings.install_path)
}
inline auto UserSettings::mutable_install_path() -> std::string* {
  // @@protoc_insertion_point(field_mutable:UserSettings.install_path)
  return _internal_mutable_install_path();
}
inline auto UserSettings::_internal_install_path() const -> const std::string& {
  return install_path_.Get();
}
inline void UserSettings::_internal_set_install_path(const std::string& value) {
  
  install_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UserSettings::set_install_path(std::string&& value) {
  
  install_path_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:UserSettings.install_path)
}
inline void UserSettings::set_install_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  install_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:UserSettings.install_path)
}
inline void UserSettings::set_install_path(const char* value,
    size_t size) {
  
  install_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:UserSettings.install_path)
}
inline auto UserSettings::_internal_mutable_install_path() -> std::string* {
  
  return install_path_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto UserSettings::release_install_path() -> std::string* {
  // @@protoc_insertion_point(field_release:UserSettings.install_path)
  return install_path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UserSettings::set_allocated_install_path(std::string* install_path) {
  if (install_path != nullptr) {
    
  } else {
    
  }
  install_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), install_path,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:UserSettings.install_path)
}

// string play_region = 2;
inline void UserSettings::clear_play_region() {
  play_region_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto UserSettings::play_region() const -> const std::string& {
  // @@protoc_insertion_point(field_get:UserSettings.play_region)
  return _internal_play_region();
}
inline void UserSettings::set_play_region(const std::string& value) {
  _internal_set_play_region(value);
  // @@protoc_insertion_point(field_set:UserSettings.play_region)
}
inline auto UserSettings::mutable_play_region() -> std::string* {
  // @@protoc_insertion_point(field_mutable:UserSettings.play_region)
  return _internal_mutable_play_region();
}
inline auto UserSettings::_internal_play_region() const -> const std::string& {
  return play_region_.Get();
}
inline void UserSettings::_internal_set_play_region(const std::string& value) {
  
  play_region_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UserSettings::set_play_region(std::string&& value) {
  
  play_region_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:UserSettings.play_region)
}
inline void UserSettings::set_play_region(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  play_region_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:UserSettings.play_region)
}
inline void UserSettings::set_play_region(const char* value,
    size_t size) {
  
  play_region_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:UserSettings.play_region)
}
inline auto UserSettings::_internal_mutable_play_region() -> std::string* {
  
  return play_region_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto UserSettings::release_play_region() -> std::string* {
  // @@protoc_insertion_point(field_release:UserSettings.play_region)
  return play_region_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UserSettings::set_allocated_play_region(std::string* play_region) {
  if (play_region != nullptr) {
    
  } else {
    
  }
  play_region_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), play_region,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:UserSettings.play_region)
}

// .ShortcutOption desktop_shortcut = 3;
inline void UserSettings::clear_desktop_shortcut() {
  desktop_shortcut_ = 0;
}
inline auto UserSettings::_internal_desktop_shortcut() const -> ::ShortcutOption {
  return static_cast< ::ShortcutOption >(desktop_shortcut_);
}
inline auto UserSettings::desktop_shortcut() const -> ::ShortcutOption {
  // @@protoc_insertion_point(field_get:UserSettings.desktop_shortcut)
  return _internal_desktop_shortcut();
}
inline void UserSettings::_internal_set_desktop_shortcut(::ShortcutOption value) {
  
  desktop_shortcut_ = value;
}
inline void UserSettings::set_desktop_shortcut(::ShortcutOption value) {
  _internal_set_desktop_shortcut(value);
  // @@protoc_insertion_point(field_set:UserSettings.desktop_shortcut)
}

// .ShortcutOption startmenu_shortcut = 4;
inline void UserSettings::clear_startmenu_shortcut() {
  startmenu_shortcut_ = 0;
}
inline auto UserSettings::_internal_startmenu_shortcut() const -> ::ShortcutOption {
  return static_cast< ::ShortcutOption >(startmenu_shortcut_);
}
inline auto UserSettings::startmenu_shortcut() const -> ::ShortcutOption {
  // @@protoc_insertion_point(field_get:UserSettings.startmenu_shortcut)
  return _internal_startmenu_shortcut();
}
inline void UserSettings::_internal_set_startmenu_shortcut(::ShortcutOption value) {
  
  startmenu_shortcut_ = value;
}
inline void UserSettings::set_startmenu_shortcut(::ShortcutOption value) {
  _internal_set_startmenu_shortcut(value);
  // @@protoc_insertion_point(field_set:UserSettings.startmenu_shortcut)
}

// .LanguageSettingType language_settings = 5;
inline void UserSettings::clear_language_settings() {
  language_settings_ = 0;
}
inline auto UserSettings::_internal_language_settings() const -> ::LanguageSettingType {
  return static_cast< ::LanguageSettingType >(language_settings_);
}
inline auto UserSettings::language_settings() const -> ::LanguageSettingType {
  // @@protoc_insertion_point(field_get:UserSettings.language_settings)
  return _internal_language_settings();
}
inline void UserSettings::_internal_set_language_settings(::LanguageSettingType value) {
  
  language_settings_ = value;
}
inline void UserSettings::set_language_settings(::LanguageSettingType value) {
  _internal_set_language_settings(value);
  // @@protoc_insertion_point(field_set:UserSettings.language_settings)
}

// string selected_text_language = 6;
inline void UserSettings::clear_selected_text_language() {
  selected_text_language_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto UserSettings::selected_text_language() const -> const std::string& {
  // @@protoc_insertion_point(field_get:UserSettings.selected_text_language)
  return _internal_selected_text_language();
}
inline void UserSettings::set_selected_text_language(const std::string& value) {
  _internal_set_selected_text_language(value);
  // @@protoc_insertion_point(field_set:UserSettings.selected_text_language)
}
inline auto UserSettings::mutable_selected_text_language() -> std::string* {
  // @@protoc_insertion_point(field_mutable:UserSettings.selected_text_language)
  return _internal_mutable_selected_text_language();
}
inline auto UserSettings::_internal_selected_text_language() const -> const std::string& {
  return selected_text_language_.Get();
}
inline void UserSettings::_internal_set_selected_text_language(const std::string& value) {
  
  selected_text_language_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UserSettings::set_selected_text_language(std::string&& value) {
  
  selected_text_language_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:UserSettings.selected_text_language)
}
inline void UserSettings::set_selected_text_language(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  selected_text_language_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:UserSettings.selected_text_language)
}
inline void UserSettings::set_selected_text_language(const char* value,
    size_t size) {
  
  selected_text_language_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:UserSettings.selected_text_language)
}
inline auto UserSettings::_internal_mutable_selected_text_language() -> std::string* {
  
  return selected_text_language_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto UserSettings::release_selected_text_language() -> std::string* {
  // @@protoc_insertion_point(field_release:UserSettings.selected_text_language)
  return selected_text_language_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UserSettings::set_allocated_selected_text_language(std::string* selected_text_language) {
  if (selected_text_language != nullptr) {
    
  } else {
    
  }
  selected_text_language_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), selected_text_language,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:UserSettings.selected_text_language)
}

// string selected_speech_language = 7;
inline void UserSettings::clear_selected_speech_language() {
  selected_speech_language_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto UserSettings::selected_speech_language() const -> const std::string& {
  // @@protoc_insertion_point(field_get:UserSettings.selected_speech_language)
  return _internal_selected_speech_language();
}
inline void UserSettings::set_selected_speech_language(const std::string& value) {
  _internal_set_selected_speech_language(value);
  // @@protoc_insertion_point(field_set:UserSettings.selected_speech_language)
}
inline auto UserSettings::mutable_selected_speech_language() -> std::string* {
  // @@protoc_insertion_point(field_mutable:UserSettings.selected_speech_language)
  return _internal_mutable_selected_speech_language();
}
inline auto UserSettings::_internal_selected_speech_language() const -> const std::string& {
  return selected_speech_language_.Get();
}
inline void UserSettings::_internal_set_selected_speech_language(const std::string& value) {
  
  selected_speech_language_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UserSettings::set_selected_speech_language(std::string&& value) {
  
  selected_speech_language_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:UserSettings.selected_speech_language)
}
inline void UserSettings::set_selected_speech_language(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  selected_speech_language_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:UserSettings.selected_speech_language)
}
inline void UserSettings::set_selected_speech_language(const char* value,
    size_t size) {
  
  selected_speech_language_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:UserSettings.selected_speech_language)
}
inline auto UserSettings::_internal_mutable_selected_speech_language() -> std::string* {
  
  return selected_speech_language_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto UserSettings::release_selected_speech_language() -> std::string* {
  // @@protoc_insertion_point(field_release:UserSettings.selected_speech_language)
  return selected_speech_language_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UserSettings::set_allocated_selected_speech_language(std::string* selected_speech_language) {
  if (selected_speech_language != nullptr) {
    
  } else {
    
  }
  selected_speech_language_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), selected_speech_language,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:UserSettings.selected_speech_language)
}

// repeated .LanguageSetting languages = 8;
inline auto UserSettings::_internal_languages_size() const -> int {
  return languages_.size();
}
inline auto UserSettings::languages_size() const -> int {
  return _internal_languages_size();
}
inline void UserSettings::clear_languages() {
  languages_.Clear();
}
inline auto UserSettings::mutable_languages(int index) -> ::LanguageSetting* {
  // @@protoc_insertion_point(field_mutable:UserSettings.languages)
  return languages_.Mutable(index);
}
inline auto
UserSettings::mutable_languages() -> ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LanguageSetting >* {
  // @@protoc_insertion_point(field_mutable_list:UserSettings.languages)
  return &languages_;
}
inline auto UserSettings::_internal_languages(int index) const -> const ::LanguageSetting& {
  return languages_.Get(index);
}
inline auto UserSettings::languages(int index) const -> const ::LanguageSetting& {
  // @@protoc_insertion_point(field_get:UserSettings.languages)
  return _internal_languages(index);
}
inline auto UserSettings::_internal_add_languages() -> ::LanguageSetting* {
  return languages_.Add();
}
inline auto UserSettings::add_languages() -> ::LanguageSetting* {
  // @@protoc_insertion_point(field_add:UserSettings.languages)
  return _internal_add_languages();
}
inline auto
UserSettings::languages() const -> const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LanguageSetting >& {
  // @@protoc_insertion_point(field_list:UserSettings.languages)
  return languages_;
}

// string gfx_override_tags = 9;
inline void UserSettings::clear_gfx_override_tags() {
  gfx_override_tags_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto UserSettings::gfx_override_tags() const -> const std::string& {
  // @@protoc_insertion_point(field_get:UserSettings.gfx_override_tags)
  return _internal_gfx_override_tags();
}
inline void UserSettings::set_gfx_override_tags(const std::string& value) {
  _internal_set_gfx_override_tags(value);
  // @@protoc_insertion_point(field_set:UserSettings.gfx_override_tags)
}
inline auto UserSettings::mutable_gfx_override_tags() -> std::string* {
  // @@protoc_insertion_point(field_mutable:UserSettings.gfx_override_tags)
  return _internal_mutable_gfx_override_tags();
}
inline auto UserSettings::_internal_gfx_override_tags() const -> const std::string& {
  return gfx_override_tags_.Get();
}
inline void UserSettings::_internal_set_gfx_override_tags(const std::string& value) {
  
  gfx_override_tags_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UserSettings::set_gfx_override_tags(std::string&& value) {
  
  gfx_override_tags_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:UserSettings.gfx_override_tags)
}
inline void UserSettings::set_gfx_override_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  gfx_override_tags_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:UserSettings.gfx_override_tags)
}
inline void UserSettings::set_gfx_override_tags(const char* value,
    size_t size) {
  
  gfx_override_tags_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:UserSettings.gfx_override_tags)
}
inline auto UserSettings::_internal_mutable_gfx_override_tags() -> std::string* {
  
  return gfx_override_tags_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto UserSettings::release_gfx_override_tags() -> std::string* {
  // @@protoc_insertion_point(field_release:UserSettings.gfx_override_tags)
  return gfx_override_tags_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UserSettings::set_allocated_gfx_override_tags(std::string* gfx_override_tags) {
  if (gfx_override_tags != nullptr) {
    
  } else {
    
  }
  gfx_override_tags_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gfx_override_tags,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:UserSettings.gfx_override_tags)
}

// string versionbranch = 10;
inline void UserSettings::clear_versionbranch() {
  versionbranch_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto UserSettings::versionbranch() const -> const std::string& {
  // @@protoc_insertion_point(field_get:UserSettings.versionbranch)
  return _internal_versionbranch();
}
inline void UserSettings::set_versionbranch(const std::string& value) {
  _internal_set_versionbranch(value);
  // @@protoc_insertion_point(field_set:UserSettings.versionbranch)
}
inline auto UserSettings::mutable_versionbranch() -> std::string* {
  // @@protoc_insertion_point(field_mutable:UserSettings.versionbranch)
  return _internal_mutable_versionbranch();
}
inline auto UserSettings::_internal_versionbranch() const -> const std::string& {
  return versionbranch_.Get();
}
inline void UserSettings::_internal_set_versionbranch(const std::string& value) {
  
  versionbranch_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UserSettings::set_versionbranch(std::string&& value) {
  
  versionbranch_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:UserSettings.versionbranch)
}
inline void UserSettings::set_versionbranch(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  versionbranch_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:UserSettings.versionbranch)
}
inline void UserSettings::set_versionbranch(const char* value,
    size_t size) {
  
  versionbranch_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:UserSettings.versionbranch)
}
inline auto UserSettings::_internal_mutable_versionbranch() -> std::string* {
  
  return versionbranch_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto UserSettings::release_versionbranch() -> std::string* {
  // @@protoc_insertion_point(field_release:UserSettings.versionbranch)
  return versionbranch_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UserSettings::set_allocated_versionbranch(std::string* versionbranch) {
  if (versionbranch != nullptr) {
    
  } else {
    
  }
  versionbranch_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), versionbranch,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:UserSettings.versionbranch)
}

// -------------------------------------------------------------------

// InstallHandshake

// string product = 1;
inline void InstallHandshake::clear_product() {
  product_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto InstallHandshake::product() const -> const std::string& {
  // @@protoc_insertion_point(field_get:InstallHandshake.product)
  return _internal_product();
}
inline void InstallHandshake::set_product(const std::string& value) {
  _internal_set_product(value);
  // @@protoc_insertion_point(field_set:InstallHandshake.product)
}
inline auto InstallHandshake::mutable_product() -> std::string* {
  // @@protoc_insertion_point(field_mutable:InstallHandshake.product)
  return _internal_mutable_product();
}
inline auto InstallHandshake::_internal_product() const -> const std::string& {
  return product_.Get();
}
inline void InstallHandshake::_internal_set_product(const std::string& value) {
  
  product_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void InstallHandshake::set_product(std::string&& value) {
  
  product_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:InstallHandshake.product)
}
inline void InstallHandshake::set_product(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  product_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:InstallHandshake.product)
}
inline void InstallHandshake::set_product(const char* value,
    size_t size) {
  
  product_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:InstallHandshake.product)
}
inline auto InstallHandshake::_internal_mutable_product() -> std::string* {
  
  return product_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto InstallHandshake::release_product() -> std::string* {
  // @@protoc_insertion_point(field_release:InstallHandshake.product)
  return product_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void InstallHandshake::set_allocated_product(std::string* product) {
  if (product != nullptr) {
    
  } else {
    
  }
  product_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), product,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:InstallHandshake.product)
}

// string uid = 2;
inline void InstallHandshake::clear_uid() {
  uid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto InstallHandshake::uid() const -> const std::string& {
  // @@protoc_insertion_point(field_get:InstallHandshake.uid)
  return _internal_uid();
}
inline void InstallHandshake::set_uid(const std::string& value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:InstallHandshake.uid)
}
inline auto InstallHandshake::mutable_uid() -> std::string* {
  // @@protoc_insertion_point(field_mutable:InstallHandshake.uid)
  return _internal_mutable_uid();
}
inline auto InstallHandshake::_internal_uid() const -> const std::string& {
  return uid_.Get();
}
inline void InstallHandshake::_internal_set_uid(const std::string& value) {
  
  uid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void InstallHandshake::set_uid(std::string&& value) {
  
  uid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:InstallHandshake.uid)
}
inline void InstallHandshake::set_uid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  uid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:InstallHandshake.uid)
}
inline void InstallHandshake::set_uid(const char* value,
    size_t size) {
  
  uid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:InstallHandshake.uid)
}
inline auto InstallHandshake::_internal_mutable_uid() -> std::string* {
  
  return uid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto InstallHandshake::release_uid() -> std::string* {
  // @@protoc_insertion_point(field_release:InstallHandshake.uid)
  return uid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void InstallHandshake::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    
  } else {
    
  }
  uid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:InstallHandshake.uid)
}

// .UserSettings settings = 3;
inline auto InstallHandshake::_internal_has_settings() const -> bool {
  return this != internal_default_instance() && settings_ != nullptr;
}
inline auto InstallHandshake::has_settings() const -> bool {
  return _internal_has_settings();
}
inline void InstallHandshake::clear_settings() {
  if (GetArena() == nullptr && settings_ != nullptr) {
    delete settings_;
  }
  settings_ = nullptr;
}
inline auto InstallHandshake::_internal_settings() const -> const ::UserSettings& {
  const ::UserSettings* p = settings_;
  return p != nullptr ? *p : *reinterpret_cast<const ::UserSettings*>(
      &::_UserSettings_default_instance_);
}
inline auto InstallHandshake::settings() const -> const ::UserSettings& {
  // @@protoc_insertion_point(field_get:InstallHandshake.settings)
  return _internal_settings();
}
inline void InstallHandshake::unsafe_arena_set_allocated_settings(
    ::UserSettings* settings) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(settings_);
  }
  settings_ = settings;
  if (settings != nullptr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:InstallHandshake.settings)
}
inline auto InstallHandshake::release_settings() -> ::UserSettings* {
  
  ::UserSettings* temp = settings_;
  settings_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline auto InstallHandshake::unsafe_arena_release_settings() -> ::UserSettings* {
  // @@protoc_insertion_point(field_release:InstallHandshake.settings)
  
  ::UserSettings* temp = settings_;
  settings_ = nullptr;
  return temp;
}
inline auto InstallHandshake::_internal_mutable_settings() -> ::UserSettings* {
  
  if (settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::UserSettings>(GetArena());
    settings_ = p;
  }
  return settings_;
}
inline auto InstallHandshake::mutable_settings() -> ::UserSettings* {
  // @@protoc_insertion_point(field_mutable:InstallHandshake.settings)
  return _internal_mutable_settings();
}
inline void InstallHandshake::set_allocated_settings(::UserSettings* settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete settings_;
  }
  if (settings != nullptr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(settings);
    if (message_arena != submessage_arena) {
      settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, settings, submessage_arena);
    }
    
  } else {
    
  }
  settings_ = settings;
  // @@protoc_insertion_point(field_set_allocated:InstallHandshake.settings)
}

// -------------------------------------------------------------------

// BuildConfig

// string region = 1;
inline void BuildConfig::clear_region() {
  region_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto BuildConfig::region() const -> const std::string& {
  // @@protoc_insertion_point(field_get:BuildConfig.region)
  return _internal_region();
}
inline void BuildConfig::set_region(const std::string& value) {
  _internal_set_region(value);
  // @@protoc_insertion_point(field_set:BuildConfig.region)
}
inline auto BuildConfig::mutable_region() -> std::string* {
  // @@protoc_insertion_point(field_mutable:BuildConfig.region)
  return _internal_mutable_region();
}
inline auto BuildConfig::_internal_region() const -> const std::string& {
  return region_.Get();
}
inline void BuildConfig::_internal_set_region(const std::string& value) {
  
  region_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BuildConfig::set_region(std::string&& value) {
  
  region_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:BuildConfig.region)
}
inline void BuildConfig::set_region(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  region_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:BuildConfig.region)
}
inline void BuildConfig::set_region(const char* value,
    size_t size) {
  
  region_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:BuildConfig.region)
}
inline auto BuildConfig::_internal_mutable_region() -> std::string* {
  
  return region_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto BuildConfig::release_region() -> std::string* {
  // @@protoc_insertion_point(field_release:BuildConfig.region)
  return region_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BuildConfig::set_allocated_region(std::string* region) {
  if (region != nullptr) {
    
  } else {
    
  }
  region_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), region,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:BuildConfig.region)
}

// string build_config = 2;
inline void BuildConfig::clear_build_config() {
  build_config_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto BuildConfig::build_config() const -> const std::string& {
  // @@protoc_insertion_point(field_get:BuildConfig.build_config)
  return _internal_build_config();
}
inline void BuildConfig::set_build_config(const std::string& value) {
  _internal_set_build_config(value);
  // @@protoc_insertion_point(field_set:BuildConfig.build_config)
}
inline auto BuildConfig::mutable_build_config() -> std::string* {
  // @@protoc_insertion_point(field_mutable:BuildConfig.build_config)
  return _internal_mutable_build_config();
}
inline auto BuildConfig::_internal_build_config() const -> const std::string& {
  return build_config_.Get();
}
inline void BuildConfig::_internal_set_build_config(const std::string& value) {
  
  build_config_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BuildConfig::set_build_config(std::string&& value) {
  
  build_config_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:BuildConfig.build_config)
}
inline void BuildConfig::set_build_config(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  build_config_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:BuildConfig.build_config)
}
inline void BuildConfig::set_build_config(const char* value,
    size_t size) {
  
  build_config_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:BuildConfig.build_config)
}
inline auto BuildConfig::_internal_mutable_build_config() -> std::string* {
  
  return build_config_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto BuildConfig::release_build_config() -> std::string* {
  // @@protoc_insertion_point(field_release:BuildConfig.build_config)
  return build_config_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BuildConfig::set_allocated_build_config(std::string* build_config) {
  if (build_config != nullptr) {
    
  } else {
    
  }
  build_config_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), build_config,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:BuildConfig.build_config)
}

// -------------------------------------------------------------------

// BaseProductState

// bool installed = 1;
inline void BaseProductState::clear_installed() {
  installed_ = false;
}
inline auto BaseProductState::_internal_installed() const -> bool {
  return installed_;
}
inline auto BaseProductState::installed() const -> bool {
  // @@protoc_insertion_point(field_get:BaseProductState.installed)
  return _internal_installed();
}
inline void BaseProductState::_internal_set_installed(bool value) {
  
  installed_ = value;
}
inline void BaseProductState::set_installed(bool value) {
  _internal_set_installed(value);
  // @@protoc_insertion_point(field_set:BaseProductState.installed)
}

// bool playable = 2;
inline void BaseProductState::clear_playable() {
  playable_ = false;
}
inline auto BaseProductState::_internal_playable() const -> bool {
  return playable_;
}
inline auto BaseProductState::playable() const -> bool {
  // @@protoc_insertion_point(field_get:BaseProductState.playable)
  return _internal_playable();
}
inline void BaseProductState::_internal_set_playable(bool value) {
  
  playable_ = value;
}
inline void BaseProductState::set_playable(bool value) {
  _internal_set_playable(value);
  // @@protoc_insertion_point(field_set:BaseProductState.playable)
}

// bool update_complete = 3;
inline void BaseProductState::clear_update_complete() {
  update_complete_ = false;
}
inline auto BaseProductState::_internal_update_complete() const -> bool {
  return update_complete_;
}
inline auto BaseProductState::update_complete() const -> bool {
  // @@protoc_insertion_point(field_get:BaseProductState.update_complete)
  return _internal_update_complete();
}
inline void BaseProductState::_internal_set_update_complete(bool value) {
  
  update_complete_ = value;
}
inline void BaseProductState::set_update_complete(bool value) {
  _internal_set_update_complete(value);
  // @@protoc_insertion_point(field_set:BaseProductState.update_complete)
}

// bool background_download_available = 4;
inline void BaseProductState::clear_background_download_available() {
  background_download_available_ = false;
}
inline auto BaseProductState::_internal_background_download_available() const -> bool {
  return background_download_available_;
}
inline auto BaseProductState::background_download_available() const -> bool {
  // @@protoc_insertion_point(field_get:BaseProductState.background_download_available)
  return _internal_background_download_available();
}
inline void BaseProductState::_internal_set_background_download_available(bool value) {
  
  background_download_available_ = value;
}
inline void BaseProductState::set_background_download_available(bool value) {
  _internal_set_background_download_available(value);
  // @@protoc_insertion_point(field_set:BaseProductState.background_download_available)
}

// bool background_download_complete = 5;
inline void BaseProductState::clear_background_download_complete() {
  background_download_complete_ = false;
}
inline auto BaseProductState::_internal_background_download_complete() const -> bool {
  return background_download_complete_;
}
inline auto BaseProductState::background_download_complete() const -> bool {
  // @@protoc_insertion_point(field_get:BaseProductState.background_download_complete)
  return _internal_background_download_complete();
}
inline void BaseProductState::_internal_set_background_download_complete(bool value) {
  
  background_download_complete_ = value;
}
inline void BaseProductState::set_background_download_complete(bool value) {
  _internal_set_background_download_complete(value);
  // @@protoc_insertion_point(field_set:BaseProductState.background_download_complete)
}

// string current_version = 6;
inline void BaseProductState::clear_current_version() {
  current_version_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto BaseProductState::current_version() const -> const std::string& {
  // @@protoc_insertion_point(field_get:BaseProductState.current_version)
  return _internal_current_version();
}
inline void BaseProductState::set_current_version(const std::string& value) {
  _internal_set_current_version(value);
  // @@protoc_insertion_point(field_set:BaseProductState.current_version)
}
inline auto BaseProductState::mutable_current_version() -> std::string* {
  // @@protoc_insertion_point(field_mutable:BaseProductState.current_version)
  return _internal_mutable_current_version();
}
inline auto BaseProductState::_internal_current_version() const -> const std::string& {
  return current_version_.Get();
}
inline void BaseProductState::_internal_set_current_version(const std::string& value) {
  
  current_version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BaseProductState::set_current_version(std::string&& value) {
  
  current_version_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:BaseProductState.current_version)
}
inline void BaseProductState::set_current_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  current_version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:BaseProductState.current_version)
}
inline void BaseProductState::set_current_version(const char* value,
    size_t size) {
  
  current_version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:BaseProductState.current_version)
}
inline auto BaseProductState::_internal_mutable_current_version() -> std::string* {
  
  return current_version_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto BaseProductState::release_current_version() -> std::string* {
  // @@protoc_insertion_point(field_release:BaseProductState.current_version)
  return current_version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BaseProductState::set_allocated_current_version(std::string* current_version) {
  if (current_version != nullptr) {
    
  } else {
    
  }
  current_version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), current_version,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:BaseProductState.current_version)
}

// string current_version_str = 7;
inline void BaseProductState::clear_current_version_str() {
  current_version_str_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto BaseProductState::current_version_str() const -> const std::string& {
  // @@protoc_insertion_point(field_get:BaseProductState.current_version_str)
  return _internal_current_version_str();
}
inline void BaseProductState::set_current_version_str(const std::string& value) {
  _internal_set_current_version_str(value);
  // @@protoc_insertion_point(field_set:BaseProductState.current_version_str)
}
inline auto BaseProductState::mutable_current_version_str() -> std::string* {
  // @@protoc_insertion_point(field_mutable:BaseProductState.current_version_str)
  return _internal_mutable_current_version_str();
}
inline auto BaseProductState::_internal_current_version_str() const -> const std::string& {
  return current_version_str_.Get();
}
inline void BaseProductState::_internal_set_current_version_str(const std::string& value) {
  
  current_version_str_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BaseProductState::set_current_version_str(std::string&& value) {
  
  current_version_str_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:BaseProductState.current_version_str)
}
inline void BaseProductState::set_current_version_str(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  current_version_str_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:BaseProductState.current_version_str)
}
inline void BaseProductState::set_current_version_str(const char* value,
    size_t size) {
  
  current_version_str_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:BaseProductState.current_version_str)
}
inline auto BaseProductState::_internal_mutable_current_version_str() -> std::string* {
  
  return current_version_str_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto BaseProductState::release_current_version_str() -> std::string* {
  // @@protoc_insertion_point(field_release:BaseProductState.current_version_str)
  return current_version_str_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BaseProductState::set_allocated_current_version_str(std::string* current_version_str) {
  if (current_version_str != nullptr) {
    
  } else {
    
  }
  current_version_str_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), current_version_str,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:BaseProductState.current_version_str)
}

// repeated .BuildConfig installed_build_config = 8;
inline auto BaseProductState::_internal_installed_build_config_size() const -> int {
  return installed_build_config_.size();
}
inline auto BaseProductState::installed_build_config_size() const -> int {
  return _internal_installed_build_config_size();
}
inline void BaseProductState::clear_installed_build_config() {
  installed_build_config_.Clear();
}
inline auto BaseProductState::mutable_installed_build_config(int index) -> ::BuildConfig* {
  // @@protoc_insertion_point(field_mutable:BaseProductState.installed_build_config)
  return installed_build_config_.Mutable(index);
}
inline auto
BaseProductState::mutable_installed_build_config() -> ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BuildConfig >* {
  // @@protoc_insertion_point(field_mutable_list:BaseProductState.installed_build_config)
  return &installed_build_config_;
}
inline auto BaseProductState::_internal_installed_build_config(int index) const -> const ::BuildConfig& {
  return installed_build_config_.Get(index);
}
inline auto BaseProductState::installed_build_config(int index) const -> const ::BuildConfig& {
  // @@protoc_insertion_point(field_get:BaseProductState.installed_build_config)
  return _internal_installed_build_config(index);
}
inline auto BaseProductState::_internal_add_installed_build_config() -> ::BuildConfig* {
  return installed_build_config_.Add();
}
inline auto BaseProductState::add_installed_build_config() -> ::BuildConfig* {
  // @@protoc_insertion_point(field_add:BaseProductState.installed_build_config)
  return _internal_add_installed_build_config();
}
inline auto
BaseProductState::installed_build_config() const -> const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BuildConfig >& {
  // @@protoc_insertion_point(field_list:BaseProductState.installed_build_config)
  return installed_build_config_;
}

// repeated .BuildConfig background_download_build_config = 9;
inline auto BaseProductState::_internal_background_download_build_config_size() const -> int {
  return background_download_build_config_.size();
}
inline auto BaseProductState::background_download_build_config_size() const -> int {
  return _internal_background_download_build_config_size();
}
inline void BaseProductState::clear_background_download_build_config() {
  background_download_build_config_.Clear();
}
inline auto BaseProductState::mutable_background_download_build_config(int index) -> ::BuildConfig* {
  // @@protoc_insertion_point(field_mutable:BaseProductState.background_download_build_config)
  return background_download_build_config_.Mutable(index);
}
inline auto
BaseProductState::mutable_background_download_build_config() -> ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BuildConfig >* {
  // @@protoc_insertion_point(field_mutable_list:BaseProductState.background_download_build_config)
  return &background_download_build_config_;
}
inline auto BaseProductState::_internal_background_download_build_config(int index) const -> const ::BuildConfig& {
  return background_download_build_config_.Get(index);
}
inline auto BaseProductState::background_download_build_config(int index) const -> const ::BuildConfig& {
  // @@protoc_insertion_point(field_get:BaseProductState.background_download_build_config)
  return _internal_background_download_build_config(index);
}
inline auto BaseProductState::_internal_add_background_download_build_config() -> ::BuildConfig* {
  return background_download_build_config_.Add();
}
inline auto BaseProductState::add_background_download_build_config() -> ::BuildConfig* {
  // @@protoc_insertion_point(field_add:BaseProductState.background_download_build_config)
  return _internal_add_background_download_build_config();
}
inline auto
BaseProductState::background_download_build_config() const -> const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BuildConfig >& {
  // @@protoc_insertion_point(field_list:BaseProductState.background_download_build_config)
  return background_download_build_config_;
}

// string decryption_key = 10;
inline void BaseProductState::clear_decryption_key() {
  decryption_key_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto BaseProductState::decryption_key() const -> const std::string& {
  // @@protoc_insertion_point(field_get:BaseProductState.decryption_key)
  return _internal_decryption_key();
}
inline void BaseProductState::set_decryption_key(const std::string& value) {
  _internal_set_decryption_key(value);
  // @@protoc_insertion_point(field_set:BaseProductState.decryption_key)
}
inline auto BaseProductState::mutable_decryption_key() -> std::string* {
  // @@protoc_insertion_point(field_mutable:BaseProductState.decryption_key)
  return _internal_mutable_decryption_key();
}
inline auto BaseProductState::_internal_decryption_key() const -> const std::string& {
  return decryption_key_.Get();
}
inline void BaseProductState::_internal_set_decryption_key(const std::string& value) {
  
  decryption_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BaseProductState::set_decryption_key(std::string&& value) {
  
  decryption_key_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:BaseProductState.decryption_key)
}
inline void BaseProductState::set_decryption_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  decryption_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:BaseProductState.decryption_key)
}
inline void BaseProductState::set_decryption_key(const char* value,
    size_t size) {
  
  decryption_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:BaseProductState.decryption_key)
}
inline auto BaseProductState::_internal_mutable_decryption_key() -> std::string* {
  
  return decryption_key_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto BaseProductState::release_decryption_key() -> std::string* {
  // @@protoc_insertion_point(field_release:BaseProductState.decryption_key)
  return decryption_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BaseProductState::set_allocated_decryption_key(std::string* decryption_key) {
  if (decryption_key != nullptr) {
    
  } else {
    
  }
  decryption_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), decryption_key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:BaseProductState.decryption_key)
}

// repeated string completed_install_actions = 11;
inline auto BaseProductState::_internal_completed_install_actions_size() const -> int {
  return completed_install_actions_.size();
}
inline auto BaseProductState::completed_install_actions_size() const -> int {
  return _internal_completed_install_actions_size();
}
inline void BaseProductState::clear_completed_install_actions() {
  completed_install_actions_.Clear();
}
inline auto BaseProductState::add_completed_install_actions() -> std::string* {
  // @@protoc_insertion_point(field_add_mutable:BaseProductState.completed_install_actions)
  return _internal_add_completed_install_actions();
}
inline auto BaseProductState::_internal_completed_install_actions(int index) const -> const std::string& {
  return completed_install_actions_.Get(index);
}
inline auto BaseProductState::completed_install_actions(int index) const -> const std::string& {
  // @@protoc_insertion_point(field_get:BaseProductState.completed_install_actions)
  return _internal_completed_install_actions(index);
}
inline auto BaseProductState::mutable_completed_install_actions(int index) -> std::string* {
  // @@protoc_insertion_point(field_mutable:BaseProductState.completed_install_actions)
  return completed_install_actions_.Mutable(index);
}
inline void BaseProductState::set_completed_install_actions(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:BaseProductState.completed_install_actions)
  completed_install_actions_.Mutable(index)->assign(value);
}
inline void BaseProductState::set_completed_install_actions(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:BaseProductState.completed_install_actions)
  completed_install_actions_.Mutable(index)->assign(std::move(value));
}
inline void BaseProductState::set_completed_install_actions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  completed_install_actions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:BaseProductState.completed_install_actions)
}
inline void BaseProductState::set_completed_install_actions(int index, const char* value, size_t size) {
  completed_install_actions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BaseProductState.completed_install_actions)
}
inline auto BaseProductState::_internal_add_completed_install_actions() -> std::string* {
  return completed_install_actions_.Add();
}
inline void BaseProductState::add_completed_install_actions(const std::string& value) {
  completed_install_actions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:BaseProductState.completed_install_actions)
}
inline void BaseProductState::add_completed_install_actions(std::string&& value) {
  completed_install_actions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:BaseProductState.completed_install_actions)
}
inline void BaseProductState::add_completed_install_actions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  completed_install_actions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:BaseProductState.completed_install_actions)
}
inline void BaseProductState::add_completed_install_actions(const char* value, size_t size) {
  completed_install_actions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:BaseProductState.completed_install_actions)
}
inline auto
BaseProductState::completed_install_actions() const -> const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& {
  // @@protoc_insertion_point(field_list:BaseProductState.completed_install_actions)
  return completed_install_actions_;
}
inline auto
BaseProductState::mutable_completed_install_actions() -> ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* {
  // @@protoc_insertion_point(field_mutable_list:BaseProductState.completed_install_actions)
  return &completed_install_actions_;
}

// -------------------------------------------------------------------

// BackfillProgress

// double progress = 1;
inline void BackfillProgress::clear_progress() {
  progress_ = 0;
}
inline auto BackfillProgress::_internal_progress() const -> double {
  return progress_;
}
inline auto BackfillProgress::progress() const -> double {
  // @@protoc_insertion_point(field_get:BackfillProgress.progress)
  return _internal_progress();
}
inline void BackfillProgress::_internal_set_progress(double value) {
  
  progress_ = value;
}
inline void BackfillProgress::set_progress(double value) {
  _internal_set_progress(value);
  // @@protoc_insertion_point(field_set:BackfillProgress.progress)
}

// bool backgrounddownload = 2;
inline void BackfillProgress::clear_backgrounddownload() {
  backgrounddownload_ = false;
}
inline auto BackfillProgress::_internal_backgrounddownload() const -> bool {
  return backgrounddownload_;
}
inline auto BackfillProgress::backgrounddownload() const -> bool {
  // @@protoc_insertion_point(field_get:BackfillProgress.backgrounddownload)
  return _internal_backgrounddownload();
}
inline void BackfillProgress::_internal_set_backgrounddownload(bool value) {
  
  backgrounddownload_ = value;
}
inline void BackfillProgress::set_backgrounddownload(bool value) {
  _internal_set_backgrounddownload(value);
  // @@protoc_insertion_point(field_set:BackfillProgress.backgrounddownload)
}

// bool paused = 3;
inline void BackfillProgress::clear_paused() {
  paused_ = false;
}
inline auto BackfillProgress::_internal_paused() const -> bool {
  return paused_;
}
inline auto BackfillProgress::paused() const -> bool {
  // @@protoc_insertion_point(field_get:BackfillProgress.paused)
  return _internal_paused();
}
inline void BackfillProgress::_internal_set_paused(bool value) {
  
  paused_ = value;
}
inline void BackfillProgress::set_paused(bool value) {
  _internal_set_paused(value);
  // @@protoc_insertion_point(field_set:BackfillProgress.paused)
}

// uint64 download_limit = 4;
inline void BackfillProgress::clear_download_limit() {
  download_limit_ = PROTOBUF_ULONGLONG(0);
}
inline auto BackfillProgress::_internal_download_limit() const -> ::PROTOBUF_NAMESPACE_ID::uint64 {
  return download_limit_;
}
inline auto BackfillProgress::download_limit() const -> ::PROTOBUF_NAMESPACE_ID::uint64 {
  // @@protoc_insertion_point(field_get:BackfillProgress.download_limit)
  return _internal_download_limit();
}
inline void BackfillProgress::_internal_set_download_limit(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  download_limit_ = value;
}
inline void BackfillProgress::set_download_limit(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_download_limit(value);
  // @@protoc_insertion_point(field_set:BackfillProgress.download_limit)
}

// -------------------------------------------------------------------

// RepairProgress

// double progress = 1;
inline void RepairProgress::clear_progress() {
  progress_ = 0;
}
inline auto RepairProgress::_internal_progress() const -> double {
  return progress_;
}
inline auto RepairProgress::progress() const -> double {
  // @@protoc_insertion_point(field_get:RepairProgress.progress)
  return _internal_progress();
}
inline void RepairProgress::_internal_set_progress(double value) {
  
  progress_ = value;
}
inline void RepairProgress::set_progress(double value) {
  _internal_set_progress(value);
  // @@protoc_insertion_point(field_set:RepairProgress.progress)
}

// -------------------------------------------------------------------

// UpdateProgress

// string last_disc_set_used = 1;
inline void UpdateProgress::clear_last_disc_set_used() {
  last_disc_set_used_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto UpdateProgress::last_disc_set_used() const -> const std::string& {
  // @@protoc_insertion_point(field_get:UpdateProgress.last_disc_set_used)
  return _internal_last_disc_set_used();
}
inline void UpdateProgress::set_last_disc_set_used(const std::string& value) {
  _internal_set_last_disc_set_used(value);
  // @@protoc_insertion_point(field_set:UpdateProgress.last_disc_set_used)
}
inline auto UpdateProgress::mutable_last_disc_set_used() -> std::string* {
  // @@protoc_insertion_point(field_mutable:UpdateProgress.last_disc_set_used)
  return _internal_mutable_last_disc_set_used();
}
inline auto UpdateProgress::_internal_last_disc_set_used() const -> const std::string& {
  return last_disc_set_used_.Get();
}
inline void UpdateProgress::_internal_set_last_disc_set_used(const std::string& value) {
  
  last_disc_set_used_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UpdateProgress::set_last_disc_set_used(std::string&& value) {
  
  last_disc_set_used_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:UpdateProgress.last_disc_set_used)
}
inline void UpdateProgress::set_last_disc_set_used(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  last_disc_set_used_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:UpdateProgress.last_disc_set_used)
}
inline void UpdateProgress::set_last_disc_set_used(const char* value,
    size_t size) {
  
  last_disc_set_used_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:UpdateProgress.last_disc_set_used)
}
inline auto UpdateProgress::_internal_mutable_last_disc_set_used() -> std::string* {
  
  return last_disc_set_used_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto UpdateProgress::release_last_disc_set_used() -> std::string* {
  // @@protoc_insertion_point(field_release:UpdateProgress.last_disc_set_used)
  return last_disc_set_used_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UpdateProgress::set_allocated_last_disc_set_used(std::string* last_disc_set_used) {
  if (last_disc_set_used != nullptr) {
    
  } else {
    
  }
  last_disc_set_used_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), last_disc_set_used,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:UpdateProgress.last_disc_set_used)
}

// double progress = 2;
inline void UpdateProgress::clear_progress() {
  progress_ = 0;
}
inline auto UpdateProgress::_internal_progress() const -> double {
  return progress_;
}
inline auto UpdateProgress::progress() const -> double {
  // @@protoc_insertion_point(field_get:UpdateProgress.progress)
  return _internal_progress();
}
inline void UpdateProgress::_internal_set_progress(double value) {
  
  progress_ = value;
}
inline void UpdateProgress::set_progress(double value) {
  _internal_set_progress(value);
  // @@protoc_insertion_point(field_set:UpdateProgress.progress)
}

// bool disc_ignored = 3;
inline void UpdateProgress::clear_disc_ignored() {
  disc_ignored_ = false;
}
inline auto UpdateProgress::_internal_disc_ignored() const -> bool {
  return disc_ignored_;
}
inline auto UpdateProgress::disc_ignored() const -> bool {
  // @@protoc_insertion_point(field_get:UpdateProgress.disc_ignored)
  return _internal_disc_ignored();
}
inline void UpdateProgress::_internal_set_disc_ignored(bool value) {
  
  disc_ignored_ = value;
}
inline void UpdateProgress::set_disc_ignored(bool value) {
  _internal_set_disc_ignored(value);
  // @@protoc_insertion_point(field_set:UpdateProgress.disc_ignored)
}

// uint64 total_to_download = 4;
inline void UpdateProgress::clear_total_to_download() {
  total_to_download_ = PROTOBUF_ULONGLONG(0);
}
inline auto UpdateProgress::_internal_total_to_download() const -> ::PROTOBUF_NAMESPACE_ID::uint64 {
  return total_to_download_;
}
inline auto UpdateProgress::total_to_download() const -> ::PROTOBUF_NAMESPACE_ID::uint64 {
  // @@protoc_insertion_point(field_get:UpdateProgress.total_to_download)
  return _internal_total_to_download();
}
inline void UpdateProgress::_internal_set_total_to_download(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  total_to_download_ = value;
}
inline void UpdateProgress::set_total_to_download(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_total_to_download(value);
  // @@protoc_insertion_point(field_set:UpdateProgress.total_to_download)
}

// uint64 download_remaining = 5;
inline void UpdateProgress::clear_download_remaining() {
  download_remaining_ = PROTOBUF_ULONGLONG(0);
}
inline auto UpdateProgress::_internal_download_remaining() const -> ::PROTOBUF_NAMESPACE_ID::uint64 {
  return download_remaining_;
}
inline auto UpdateProgress::download_remaining() const -> ::PROTOBUF_NAMESPACE_ID::uint64 {
  // @@protoc_insertion_point(field_get:UpdateProgress.download_remaining)
  return _internal_download_remaining();
}
inline void UpdateProgress::_internal_set_download_remaining(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  download_remaining_ = value;
}
inline void UpdateProgress::set_download_remaining(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_download_remaining(value);
  // @@protoc_insertion_point(field_set:UpdateProgress.download_remaining)
}

// -------------------------------------------------------------------

// CachedProductState

// .BaseProductState base_product_state = 1;
inline auto CachedProductState::_internal_has_base_product_state() const -> bool {
  return this != internal_default_instance() && base_product_state_ != nullptr;
}
inline auto CachedProductState::has_base_product_state() const -> bool {
  return _internal_has_base_product_state();
}
inline void CachedProductState::clear_base_product_state() {
  if (GetArena() == nullptr && base_product_state_ != nullptr) {
    delete base_product_state_;
  }
  base_product_state_ = nullptr;
}
inline auto CachedProductState::_internal_base_product_state() const -> const ::BaseProductState& {
  const ::BaseProductState* p = base_product_state_;
  return p != nullptr ? *p : *reinterpret_cast<const ::BaseProductState*>(
      &::_BaseProductState_default_instance_);
}
inline auto CachedProductState::base_product_state() const -> const ::BaseProductState& {
  // @@protoc_insertion_point(field_get:CachedProductState.base_product_state)
  return _internal_base_product_state();
}
inline void CachedProductState::unsafe_arena_set_allocated_base_product_state(
    ::BaseProductState* base_product_state) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(base_product_state_);
  }
  base_product_state_ = base_product_state;
  if (base_product_state != nullptr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CachedProductState.base_product_state)
}
inline auto CachedProductState::release_base_product_state() -> ::BaseProductState* {
  
  ::BaseProductState* temp = base_product_state_;
  base_product_state_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline auto CachedProductState::unsafe_arena_release_base_product_state() -> ::BaseProductState* {
  // @@protoc_insertion_point(field_release:CachedProductState.base_product_state)
  
  ::BaseProductState* temp = base_product_state_;
  base_product_state_ = nullptr;
  return temp;
}
inline auto CachedProductState::_internal_mutable_base_product_state() -> ::BaseProductState* {
  
  if (base_product_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::BaseProductState>(GetArena());
    base_product_state_ = p;
  }
  return base_product_state_;
}
inline auto CachedProductState::mutable_base_product_state() -> ::BaseProductState* {
  // @@protoc_insertion_point(field_mutable:CachedProductState.base_product_state)
  return _internal_mutable_base_product_state();
}
inline void CachedProductState::set_allocated_base_product_state(::BaseProductState* base_product_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete base_product_state_;
  }
  if (base_product_state != nullptr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(base_product_state);
    if (message_arena != submessage_arena) {
      base_product_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base_product_state, submessage_arena);
    }
    
  } else {
    
  }
  base_product_state_ = base_product_state;
  // @@protoc_insertion_point(field_set_allocated:CachedProductState.base_product_state)
}

// .BackfillProgress backfill_progress = 2;
inline auto CachedProductState::_internal_has_backfill_progress() const -> bool {
  return this != internal_default_instance() && backfill_progress_ != nullptr;
}
inline auto CachedProductState::has_backfill_progress() const -> bool {
  return _internal_has_backfill_progress();
}
inline void CachedProductState::clear_backfill_progress() {
  if (GetArena() == nullptr && backfill_progress_ != nullptr) {
    delete backfill_progress_;
  }
  backfill_progress_ = nullptr;
}
inline auto CachedProductState::_internal_backfill_progress() const -> const ::BackfillProgress& {
  const ::BackfillProgress* p = backfill_progress_;
  return p != nullptr ? *p : *reinterpret_cast<const ::BackfillProgress*>(
      &::_BackfillProgress_default_instance_);
}
inline auto CachedProductState::backfill_progress() const -> const ::BackfillProgress& {
  // @@protoc_insertion_point(field_get:CachedProductState.backfill_progress)
  return _internal_backfill_progress();
}
inline void CachedProductState::unsafe_arena_set_allocated_backfill_progress(
    ::BackfillProgress* backfill_progress) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(backfill_progress_);
  }
  backfill_progress_ = backfill_progress;
  if (backfill_progress != nullptr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CachedProductState.backfill_progress)
}
inline auto CachedProductState::release_backfill_progress() -> ::BackfillProgress* {
  
  ::BackfillProgress* temp = backfill_progress_;
  backfill_progress_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline auto CachedProductState::unsafe_arena_release_backfill_progress() -> ::BackfillProgress* {
  // @@protoc_insertion_point(field_release:CachedProductState.backfill_progress)
  
  ::BackfillProgress* temp = backfill_progress_;
  backfill_progress_ = nullptr;
  return temp;
}
inline auto CachedProductState::_internal_mutable_backfill_progress() -> ::BackfillProgress* {
  
  if (backfill_progress_ == nullptr) {
    auto* p = CreateMaybeMessage<::BackfillProgress>(GetArena());
    backfill_progress_ = p;
  }
  return backfill_progress_;
}
inline auto CachedProductState::mutable_backfill_progress() -> ::BackfillProgress* {
  // @@protoc_insertion_point(field_mutable:CachedProductState.backfill_progress)
  return _internal_mutable_backfill_progress();
}
inline void CachedProductState::set_allocated_backfill_progress(::BackfillProgress* backfill_progress) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete backfill_progress_;
  }
  if (backfill_progress != nullptr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(backfill_progress);
    if (message_arena != submessage_arena) {
      backfill_progress = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, backfill_progress, submessage_arena);
    }
    
  } else {
    
  }
  backfill_progress_ = backfill_progress;
  // @@protoc_insertion_point(field_set_allocated:CachedProductState.backfill_progress)
}

// .RepairProgress repair_progress = 3;
inline auto CachedProductState::_internal_has_repair_progress() const -> bool {
  return this != internal_default_instance() && repair_progress_ != nullptr;
}
inline auto CachedProductState::has_repair_progress() const -> bool {
  return _internal_has_repair_progress();
}
inline void CachedProductState::clear_repair_progress() {
  if (GetArena() == nullptr && repair_progress_ != nullptr) {
    delete repair_progress_;
  }
  repair_progress_ = nullptr;
}
inline auto CachedProductState::_internal_repair_progress() const -> const ::RepairProgress& {
  const ::RepairProgress* p = repair_progress_;
  return p != nullptr ? *p : *reinterpret_cast<const ::RepairProgress*>(
      &::_RepairProgress_default_instance_);
}
inline auto CachedProductState::repair_progress() const -> const ::RepairProgress& {
  // @@protoc_insertion_point(field_get:CachedProductState.repair_progress)
  return _internal_repair_progress();
}
inline void CachedProductState::unsafe_arena_set_allocated_repair_progress(
    ::RepairProgress* repair_progress) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(repair_progress_);
  }
  repair_progress_ = repair_progress;
  if (repair_progress != nullptr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CachedProductState.repair_progress)
}
inline auto CachedProductState::release_repair_progress() -> ::RepairProgress* {
  
  ::RepairProgress* temp = repair_progress_;
  repair_progress_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline auto CachedProductState::unsafe_arena_release_repair_progress() -> ::RepairProgress* {
  // @@protoc_insertion_point(field_release:CachedProductState.repair_progress)
  
  ::RepairProgress* temp = repair_progress_;
  repair_progress_ = nullptr;
  return temp;
}
inline auto CachedProductState::_internal_mutable_repair_progress() -> ::RepairProgress* {
  
  if (repair_progress_ == nullptr) {
    auto* p = CreateMaybeMessage<::RepairProgress>(GetArena());
    repair_progress_ = p;
  }
  return repair_progress_;
}
inline auto CachedProductState::mutable_repair_progress() -> ::RepairProgress* {
  // @@protoc_insertion_point(field_mutable:CachedProductState.repair_progress)
  return _internal_mutable_repair_progress();
}
inline void CachedProductState::set_allocated_repair_progress(::RepairProgress* repair_progress) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete repair_progress_;
  }
  if (repair_progress != nullptr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(repair_progress);
    if (message_arena != submessage_arena) {
      repair_progress = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, repair_progress, submessage_arena);
    }
    
  } else {
    
  }
  repair_progress_ = repair_progress;
  // @@protoc_insertion_point(field_set_allocated:CachedProductState.repair_progress)
}

// .UpdateProgress update_progress = 4;
inline auto CachedProductState::_internal_has_update_progress() const -> bool {
  return this != internal_default_instance() && update_progress_ != nullptr;
}
inline auto CachedProductState::has_update_progress() const -> bool {
  return _internal_has_update_progress();
}
inline void CachedProductState::clear_update_progress() {
  if (GetArena() == nullptr && update_progress_ != nullptr) {
    delete update_progress_;
  }
  update_progress_ = nullptr;
}
inline auto CachedProductState::_internal_update_progress() const -> const ::UpdateProgress& {
  const ::UpdateProgress* p = update_progress_;
  return p != nullptr ? *p : *reinterpret_cast<const ::UpdateProgress*>(
      &::_UpdateProgress_default_instance_);
}
inline auto CachedProductState::update_progress() const -> const ::UpdateProgress& {
  // @@protoc_insertion_point(field_get:CachedProductState.update_progress)
  return _internal_update_progress();
}
inline void CachedProductState::unsafe_arena_set_allocated_update_progress(
    ::UpdateProgress* update_progress) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_progress_);
  }
  update_progress_ = update_progress;
  if (update_progress != nullptr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CachedProductState.update_progress)
}
inline auto CachedProductState::release_update_progress() -> ::UpdateProgress* {
  
  ::UpdateProgress* temp = update_progress_;
  update_progress_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline auto CachedProductState::unsafe_arena_release_update_progress() -> ::UpdateProgress* {
  // @@protoc_insertion_point(field_release:CachedProductState.update_progress)
  
  ::UpdateProgress* temp = update_progress_;
  update_progress_ = nullptr;
  return temp;
}
inline auto CachedProductState::_internal_mutable_update_progress() -> ::UpdateProgress* {
  
  if (update_progress_ == nullptr) {
    auto* p = CreateMaybeMessage<::UpdateProgress>(GetArena());
    update_progress_ = p;
  }
  return update_progress_;
}
inline auto CachedProductState::mutable_update_progress() -> ::UpdateProgress* {
  // @@protoc_insertion_point(field_mutable:CachedProductState.update_progress)
  return _internal_mutable_update_progress();
}
inline void CachedProductState::set_allocated_update_progress(::UpdateProgress* update_progress) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete update_progress_;
  }
  if (update_progress != nullptr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(update_progress);
    if (message_arena != submessage_arena) {
      update_progress = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_progress, submessage_arena);
    }
    
  } else {
    
  }
  update_progress_ = update_progress;
  // @@protoc_insertion_point(field_set_allocated:CachedProductState.update_progress)
}

// -------------------------------------------------------------------

// ProductOperations

// .Operation active_operation = 1;
inline void ProductOperations::clear_active_operation() {
  active_operation_ = 0;
}
inline auto ProductOperations::_internal_active_operation() const -> ::Operation {
  return static_cast< ::Operation >(active_operation_);
}
inline auto ProductOperations::active_operation() const -> ::Operation {
  // @@protoc_insertion_point(field_get:ProductOperations.active_operation)
  return _internal_active_operation();
}
inline void ProductOperations::_internal_set_active_operation(::Operation value) {
  
  active_operation_ = value;
}
inline void ProductOperations::set_active_operation(::Operation value) {
  _internal_set_active_operation(value);
  // @@protoc_insertion_point(field_set:ProductOperations.active_operation)
}

// uint64 priority = 2;
inline void ProductOperations::clear_priority() {
  priority_ = PROTOBUF_ULONGLONG(0);
}
inline auto ProductOperations::_internal_priority() const -> ::PROTOBUF_NAMESPACE_ID::uint64 {
  return priority_;
}
inline auto ProductOperations::priority() const -> ::PROTOBUF_NAMESPACE_ID::uint64 {
  // @@protoc_insertion_point(field_get:ProductOperations.priority)
  return _internal_priority();
}
inline void ProductOperations::_internal_set_priority(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  priority_ = value;
}
inline void ProductOperations::set_priority(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:ProductOperations.priority)
}

// -------------------------------------------------------------------

// ProductInstall

// string uid = 1;
inline void ProductInstall::clear_uid() {
  uid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto ProductInstall::uid() const -> const std::string& {
  // @@protoc_insertion_point(field_get:ProductInstall.uid)
  return _internal_uid();
}
inline void ProductInstall::set_uid(const std::string& value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:ProductInstall.uid)
}
inline auto ProductInstall::mutable_uid() -> std::string* {
  // @@protoc_insertion_point(field_mutable:ProductInstall.uid)
  return _internal_mutable_uid();
}
inline auto ProductInstall::_internal_uid() const -> const std::string& {
  return uid_.Get();
}
inline void ProductInstall::_internal_set_uid(const std::string& value) {
  
  uid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ProductInstall::set_uid(std::string&& value) {
  
  uid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ProductInstall.uid)
}
inline void ProductInstall::set_uid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  uid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ProductInstall.uid)
}
inline void ProductInstall::set_uid(const char* value,
    size_t size) {
  
  uid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ProductInstall.uid)
}
inline auto ProductInstall::_internal_mutable_uid() -> std::string* {
  
  return uid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto ProductInstall::release_uid() -> std::string* {
  // @@protoc_insertion_point(field_release:ProductInstall.uid)
  return uid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ProductInstall::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    
  } else {
    
  }
  uid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ProductInstall.uid)
}

// string product_code = 2;
inline void ProductInstall::clear_product_code() {
  product_code_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto ProductInstall::product_code() const -> const std::string& {
  // @@protoc_insertion_point(field_get:ProductInstall.product_code)
  return _internal_product_code();
}
inline void ProductInstall::set_product_code(const std::string& value) {
  _internal_set_product_code(value);
  // @@protoc_insertion_point(field_set:ProductInstall.product_code)
}
inline auto ProductInstall::mutable_product_code() -> std::string* {
  // @@protoc_insertion_point(field_mutable:ProductInstall.product_code)
  return _internal_mutable_product_code();
}
inline auto ProductInstall::_internal_product_code() const -> const std::string& {
  return product_code_.Get();
}
inline void ProductInstall::_internal_set_product_code(const std::string& value) {
  
  product_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ProductInstall::set_product_code(std::string&& value) {
  
  product_code_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ProductInstall.product_code)
}
inline void ProductInstall::set_product_code(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  product_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ProductInstall.product_code)
}
inline void ProductInstall::set_product_code(const char* value,
    size_t size) {
  
  product_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ProductInstall.product_code)
}
inline auto ProductInstall::_internal_mutable_product_code() -> std::string* {
  
  return product_code_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto ProductInstall::release_product_code() -> std::string* {
  // @@protoc_insertion_point(field_release:ProductInstall.product_code)
  return product_code_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ProductInstall::set_allocated_product_code(std::string* product_code) {
  if (product_code != nullptr) {
    
  } else {
    
  }
  product_code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), product_code,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ProductInstall.product_code)
}

// .UserSettings settings = 3;
inline auto ProductInstall::_internal_has_settings() const -> bool {
  return this != internal_default_instance() && settings_ != nullptr;
}
inline auto ProductInstall::has_settings() const -> bool {
  return _internal_has_settings();
}
inline void ProductInstall::clear_settings() {
  if (GetArena() == nullptr && settings_ != nullptr) {
    delete settings_;
  }
  settings_ = nullptr;
}
inline auto ProductInstall::_internal_settings() const -> const ::UserSettings& {
  const ::UserSettings* p = settings_;
  return p != nullptr ? *p : *reinterpret_cast<const ::UserSettings*>(
      &::_UserSettings_default_instance_);
}
inline auto ProductInstall::settings() const -> const ::UserSettings& {
  // @@protoc_insertion_point(field_get:ProductInstall.settings)
  return _internal_settings();
}
inline void ProductInstall::unsafe_arena_set_allocated_settings(
    ::UserSettings* settings) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(settings_);
  }
  settings_ = settings;
  if (settings != nullptr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProductInstall.settings)
}
inline auto ProductInstall::release_settings() -> ::UserSettings* {
  
  ::UserSettings* temp = settings_;
  settings_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline auto ProductInstall::unsafe_arena_release_settings() -> ::UserSettings* {
  // @@protoc_insertion_point(field_release:ProductInstall.settings)
  
  ::UserSettings* temp = settings_;
  settings_ = nullptr;
  return temp;
}
inline auto ProductInstall::_internal_mutable_settings() -> ::UserSettings* {
  
  if (settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::UserSettings>(GetArena());
    settings_ = p;
  }
  return settings_;
}
inline auto ProductInstall::mutable_settings() -> ::UserSettings* {
  // @@protoc_insertion_point(field_mutable:ProductInstall.settings)
  return _internal_mutable_settings();
}
inline void ProductInstall::set_allocated_settings(::UserSettings* settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete settings_;
  }
  if (settings != nullptr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(settings);
    if (message_arena != submessage_arena) {
      settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, settings, submessage_arena);
    }
    
  } else {
    
  }
  settings_ = settings;
  // @@protoc_insertion_point(field_set_allocated:ProductInstall.settings)
}

// .CachedProductState cached_product_state = 4;
inline auto ProductInstall::_internal_has_cached_product_state() const -> bool {
  return this != internal_default_instance() && cached_product_state_ != nullptr;
}
inline auto ProductInstall::has_cached_product_state() const -> bool {
  return _internal_has_cached_product_state();
}
inline void ProductInstall::clear_cached_product_state() {
  if (GetArena() == nullptr && cached_product_state_ != nullptr) {
    delete cached_product_state_;
  }
  cached_product_state_ = nullptr;
}
inline auto ProductInstall::_internal_cached_product_state() const -> const ::CachedProductState& {
  const ::CachedProductState* p = cached_product_state_;
  return p != nullptr ? *p : *reinterpret_cast<const ::CachedProductState*>(
      &::_CachedProductState_default_instance_);
}
inline auto ProductInstall::cached_product_state() const -> const ::CachedProductState& {
  // @@protoc_insertion_point(field_get:ProductInstall.cached_product_state)
  return _internal_cached_product_state();
}
inline void ProductInstall::unsafe_arena_set_allocated_cached_product_state(
    ::CachedProductState* cached_product_state) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cached_product_state_);
  }
  cached_product_state_ = cached_product_state;
  if (cached_product_state != nullptr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProductInstall.cached_product_state)
}
inline auto ProductInstall::release_cached_product_state() -> ::CachedProductState* {
  
  ::CachedProductState* temp = cached_product_state_;
  cached_product_state_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline auto ProductInstall::unsafe_arena_release_cached_product_state() -> ::CachedProductState* {
  // @@protoc_insertion_point(field_release:ProductInstall.cached_product_state)
  
  ::CachedProductState* temp = cached_product_state_;
  cached_product_state_ = nullptr;
  return temp;
}
inline auto ProductInstall::_internal_mutable_cached_product_state() -> ::CachedProductState* {
  
  if (cached_product_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::CachedProductState>(GetArena());
    cached_product_state_ = p;
  }
  return cached_product_state_;
}
inline auto ProductInstall::mutable_cached_product_state() -> ::CachedProductState* {
  // @@protoc_insertion_point(field_mutable:ProductInstall.cached_product_state)
  return _internal_mutable_cached_product_state();
}
inline void ProductInstall::set_allocated_cached_product_state(::CachedProductState* cached_product_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete cached_product_state_;
  }
  if (cached_product_state != nullptr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(cached_product_state);
    if (message_arena != submessage_arena) {
      cached_product_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cached_product_state, submessage_arena);
    }
    
  } else {
    
  }
  cached_product_state_ = cached_product_state;
  // @@protoc_insertion_point(field_set_allocated:ProductInstall.cached_product_state)
}

// .ProductOperations product_operations = 5;
inline auto ProductInstall::_internal_has_product_operations() const -> bool {
  return this != internal_default_instance() && product_operations_ != nullptr;
}
inline auto ProductInstall::has_product_operations() const -> bool {
  return _internal_has_product_operations();
}
inline void ProductInstall::clear_product_operations() {
  if (GetArena() == nullptr && product_operations_ != nullptr) {
    delete product_operations_;
  }
  product_operations_ = nullptr;
}
inline auto ProductInstall::_internal_product_operations() const -> const ::ProductOperations& {
  const ::ProductOperations* p = product_operations_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ProductOperations*>(
      &::_ProductOperations_default_instance_);
}
inline auto ProductInstall::product_operations() const -> const ::ProductOperations& {
  // @@protoc_insertion_point(field_get:ProductInstall.product_operations)
  return _internal_product_operations();
}
inline void ProductInstall::unsafe_arena_set_allocated_product_operations(
    ::ProductOperations* product_operations) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(product_operations_);
  }
  product_operations_ = product_operations;
  if (product_operations != nullptr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProductInstall.product_operations)
}
inline auto ProductInstall::release_product_operations() -> ::ProductOperations* {
  
  ::ProductOperations* temp = product_operations_;
  product_operations_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline auto ProductInstall::unsafe_arena_release_product_operations() -> ::ProductOperations* {
  // @@protoc_insertion_point(field_release:ProductInstall.product_operations)
  
  ::ProductOperations* temp = product_operations_;
  product_operations_ = nullptr;
  return temp;
}
inline auto ProductInstall::_internal_mutable_product_operations() -> ::ProductOperations* {
  
  if (product_operations_ == nullptr) {
    auto* p = CreateMaybeMessage<::ProductOperations>(GetArena());
    product_operations_ = p;
  }
  return product_operations_;
}
inline auto ProductInstall::mutable_product_operations() -> ::ProductOperations* {
  // @@protoc_insertion_point(field_mutable:ProductInstall.product_operations)
  return _internal_mutable_product_operations();
}
inline void ProductInstall::set_allocated_product_operations(::ProductOperations* product_operations) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete product_operations_;
  }
  if (product_operations != nullptr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(product_operations);
    if (message_arena != submessage_arena) {
      product_operations = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, product_operations, submessage_arena);
    }
    
  } else {
    
  }
  product_operations_ = product_operations;
  // @@protoc_insertion_point(field_set_allocated:ProductInstall.product_operations)
}

// -------------------------------------------------------------------

// ProductConfig

// string product_code = 1;
inline void ProductConfig::clear_product_code() {
  product_code_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto ProductConfig::product_code() const -> const std::string& {
  // @@protoc_insertion_point(field_get:ProductConfig.product_code)
  return _internal_product_code();
}
inline void ProductConfig::set_product_code(const std::string& value) {
  _internal_set_product_code(value);
  // @@protoc_insertion_point(field_set:ProductConfig.product_code)
}
inline auto ProductConfig::mutable_product_code() -> std::string* {
  // @@protoc_insertion_point(field_mutable:ProductConfig.product_code)
  return _internal_mutable_product_code();
}
inline auto ProductConfig::_internal_product_code() const -> const std::string& {
  return product_code_.Get();
}
inline void ProductConfig::_internal_set_product_code(const std::string& value) {
  
  product_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ProductConfig::set_product_code(std::string&& value) {
  
  product_code_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ProductConfig.product_code)
}
inline void ProductConfig::set_product_code(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  product_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ProductConfig.product_code)
}
inline void ProductConfig::set_product_code(const char* value,
    size_t size) {
  
  product_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ProductConfig.product_code)
}
inline auto ProductConfig::_internal_mutable_product_code() -> std::string* {
  
  return product_code_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto ProductConfig::release_product_code() -> std::string* {
  // @@protoc_insertion_point(field_release:ProductConfig.product_code)
  return product_code_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ProductConfig::set_allocated_product_code(std::string* product_code) {
  if (product_code != nullptr) {
    
  } else {
    
  }
  product_code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), product_code,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ProductConfig.product_code)
}

// string metadata_hash = 2;
inline void ProductConfig::clear_metadata_hash() {
  metadata_hash_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto ProductConfig::metadata_hash() const -> const std::string& {
  // @@protoc_insertion_point(field_get:ProductConfig.metadata_hash)
  return _internal_metadata_hash();
}
inline void ProductConfig::set_metadata_hash(const std::string& value) {
  _internal_set_metadata_hash(value);
  // @@protoc_insertion_point(field_set:ProductConfig.metadata_hash)
}
inline auto ProductConfig::mutable_metadata_hash() -> std::string* {
  // @@protoc_insertion_point(field_mutable:ProductConfig.metadata_hash)
  return _internal_mutable_metadata_hash();
}
inline auto ProductConfig::_internal_metadata_hash() const -> const std::string& {
  return metadata_hash_.Get();
}
inline void ProductConfig::_internal_set_metadata_hash(const std::string& value) {
  
  metadata_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ProductConfig::set_metadata_hash(std::string&& value) {
  
  metadata_hash_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ProductConfig.metadata_hash)
}
inline void ProductConfig::set_metadata_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  metadata_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ProductConfig.metadata_hash)
}
inline void ProductConfig::set_metadata_hash(const char* value,
    size_t size) {
  
  metadata_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ProductConfig.metadata_hash)
}
inline auto ProductConfig::_internal_mutable_metadata_hash() -> std::string* {
  
  return metadata_hash_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto ProductConfig::release_metadata_hash() -> std::string* {
  // @@protoc_insertion_point(field_release:ProductConfig.metadata_hash)
  return metadata_hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ProductConfig::set_allocated_metadata_hash(std::string* metadata_hash) {
  if (metadata_hash != nullptr) {
    
  } else {
    
  }
  metadata_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), metadata_hash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ProductConfig.metadata_hash)
}

// string timestamp = 3;
inline void ProductConfig::clear_timestamp() {
  timestamp_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto ProductConfig::timestamp() const -> const std::string& {
  // @@protoc_insertion_point(field_get:ProductConfig.timestamp)
  return _internal_timestamp();
}
inline void ProductConfig::set_timestamp(const std::string& value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:ProductConfig.timestamp)
}
inline auto ProductConfig::mutable_timestamp() -> std::string* {
  // @@protoc_insertion_point(field_mutable:ProductConfig.timestamp)
  return _internal_mutable_timestamp();
}
inline auto ProductConfig::_internal_timestamp() const -> const std::string& {
  return timestamp_.Get();
}
inline void ProductConfig::_internal_set_timestamp(const std::string& value) {
  
  timestamp_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ProductConfig::set_timestamp(std::string&& value) {
  
  timestamp_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ProductConfig.timestamp)
}
inline void ProductConfig::set_timestamp(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  timestamp_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ProductConfig.timestamp)
}
inline void ProductConfig::set_timestamp(const char* value,
    size_t size) {
  
  timestamp_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ProductConfig.timestamp)
}
inline auto ProductConfig::_internal_mutable_timestamp() -> std::string* {
  
  return timestamp_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto ProductConfig::release_timestamp() -> std::string* {
  // @@protoc_insertion_point(field_release:ProductConfig.timestamp)
  return timestamp_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ProductConfig::set_allocated_timestamp(std::string* timestamp) {
  if (timestamp != nullptr) {
    
  } else {
    
  }
  timestamp_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), timestamp,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ProductConfig.timestamp)
}

// -------------------------------------------------------------------

// ActiveProcess

// string process_name = 1;
inline void ActiveProcess::clear_process_name() {
  process_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto ActiveProcess::process_name() const -> const std::string& {
  // @@protoc_insertion_point(field_get:ActiveProcess.process_name)
  return _internal_process_name();
}
inline void ActiveProcess::set_process_name(const std::string& value) {
  _internal_set_process_name(value);
  // @@protoc_insertion_point(field_set:ActiveProcess.process_name)
}
inline auto ActiveProcess::mutable_process_name() -> std::string* {
  // @@protoc_insertion_point(field_mutable:ActiveProcess.process_name)
  return _internal_mutable_process_name();
}
inline auto ActiveProcess::_internal_process_name() const -> const std::string& {
  return process_name_.Get();
}
inline void ActiveProcess::_internal_set_process_name(const std::string& value) {
  
  process_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ActiveProcess::set_process_name(std::string&& value) {
  
  process_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ActiveProcess.process_name)
}
inline void ActiveProcess::set_process_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  process_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ActiveProcess.process_name)
}
inline void ActiveProcess::set_process_name(const char* value,
    size_t size) {
  
  process_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ActiveProcess.process_name)
}
inline auto ActiveProcess::_internal_mutable_process_name() -> std::string* {
  
  return process_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline auto ActiveProcess::release_process_name() -> std::string* {
  // @@protoc_insertion_point(field_release:ActiveProcess.process_name)
  return process_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ActiveProcess::set_allocated_process_name(std::string* process_name) {
  if (process_name != nullptr) {
    
  } else {
    
  }
  process_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), process_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ActiveProcess.process_name)
}

// int32 pid = 2;
inline void ActiveProcess::clear_pid() {
  pid_ = 0;
}
inline auto ActiveProcess::_internal_pid() const -> ::PROTOBUF_NAMESPACE_ID::int32 {
  return pid_;
}
inline auto ActiveProcess::pid() const -> ::PROTOBUF_NAMESPACE_ID::int32 {
  // @@protoc_insertion_point(field_get:ActiveProcess.pid)
  return _internal_pid();
}
inline void ActiveProcess::_internal_set_pid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  pid_ = value;
}
inline void ActiveProcess::set_pid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:ActiveProcess.pid)
}

// repeated string uri = 3;
inline auto ActiveProcess::_internal_uri_size() const -> int {
  return uri_.size();
}
inline auto ActiveProcess::uri_size() const -> int {
  return _internal_uri_size();
}
inline void ActiveProcess::clear_uri() {
  uri_.Clear();
}
inline auto ActiveProcess::add_uri() -> std::string* {
  // @@protoc_insertion_point(field_add_mutable:ActiveProcess.uri)
  return _internal_add_uri();
}
inline auto ActiveProcess::_internal_uri(int index) const -> const std::string& {
  return uri_.Get(index);
}
inline auto ActiveProcess::uri(int index) const -> const std::string& {
  // @@protoc_insertion_point(field_get:ActiveProcess.uri)
  return _internal_uri(index);
}
inline auto ActiveProcess::mutable_uri(int index) -> std::string* {
  // @@protoc_insertion_point(field_mutable:ActiveProcess.uri)
  return uri_.Mutable(index);
}
inline void ActiveProcess::set_uri(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:ActiveProcess.uri)
  uri_.Mutable(index)->assign(value);
}
inline void ActiveProcess::set_uri(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:ActiveProcess.uri)
  uri_.Mutable(index)->assign(std::move(value));
}
inline void ActiveProcess::set_uri(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  uri_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ActiveProcess.uri)
}
inline void ActiveProcess::set_uri(int index, const char* value, size_t size) {
  uri_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ActiveProcess.uri)
}
inline auto ActiveProcess::_internal_add_uri() -> std::string* {
  return uri_.Add();
}
inline void ActiveProcess::add_uri(const std::string& value) {
  uri_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ActiveProcess.uri)
}
inline void ActiveProcess::add_uri(std::string&& value) {
  uri_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ActiveProcess.uri)
}
inline void ActiveProcess::add_uri(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  uri_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ActiveProcess.uri)
}
inline void ActiveProcess::add_uri(const char* value, size_t size) {
  uri_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ActiveProcess.uri)
}
inline auto
ActiveProcess::uri() const -> const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& {
  // @@protoc_insertion_point(field_list:ActiveProcess.uri)
  return uri_;
}
inline auto
ActiveProcess::mutable_uri() -> ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* {
  // @@protoc_insertion_point(field_mutable_list:ActiveProcess.uri)
  return &uri_;
}

// -------------------------------------------------------------------

// DownloadSettings

// int32 download_limit = 1;
inline void DownloadSettings::clear_download_limit() {
  download_limit_ = 0;
}
inline auto DownloadSettings::_internal_download_limit() const -> ::PROTOBUF_NAMESPACE_ID::int32 {
  return download_limit_;
}
inline auto DownloadSettings::download_limit() const -> ::PROTOBUF_NAMESPACE_ID::int32 {
  // @@protoc_insertion_point(field_get:DownloadSettings.download_limit)
  return _internal_download_limit();
}
inline void DownloadSettings::_internal_set_download_limit(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  download_limit_ = value;
}
inline void DownloadSettings::set_download_limit(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_download_limit(value);
  // @@protoc_insertion_point(field_set:DownloadSettings.download_limit)
}

// int32 backfill_limit = 2;
inline void DownloadSettings::clear_backfill_limit() {
  backfill_limit_ = 0;
}
inline auto DownloadSettings::_internal_backfill_limit() const -> ::PROTOBUF_NAMESPACE_ID::int32 {
  return backfill_limit_;
}
inline auto DownloadSettings::backfill_limit() const -> ::PROTOBUF_NAMESPACE_ID::int32 {
  // @@protoc_insertion_point(field_get:DownloadSettings.backfill_limit)
  return _internal_backfill_limit();
}
inline void DownloadSettings::_internal_set_backfill_limit(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  backfill_limit_ = value;
}
inline void DownloadSettings::set_backfill_limit(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_backfill_limit(value);
  // @@protoc_insertion_point(field_set:DownloadSettings.backfill_limit)
}

// -------------------------------------------------------------------

// ProductDb

// repeated .ProductInstall product_installs = 1;
inline auto ProductDb::_internal_product_installs_size() const -> int {
  return product_installs_.size();
}
inline auto ProductDb::product_installs_size() const -> int {
  return _internal_product_installs_size();
}
inline void ProductDb::clear_product_installs() {
  product_installs_.Clear();
}
inline auto ProductDb::mutable_product_installs(int index) -> ::ProductInstall* {
  // @@protoc_insertion_point(field_mutable:ProductDb.product_installs)
  return product_installs_.Mutable(index);
}
inline auto
ProductDb::mutable_product_installs() -> ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProductInstall >* {
  // @@protoc_insertion_point(field_mutable_list:ProductDb.product_installs)
  return &product_installs_;
}
inline auto ProductDb::_internal_product_installs(int index) const -> const ::ProductInstall& {
  return product_installs_.Get(index);
}
inline auto ProductDb::product_installs(int index) const -> const ::ProductInstall& {
  // @@protoc_insertion_point(field_get:ProductDb.product_installs)
  return _internal_product_installs(index);
}
inline auto ProductDb::_internal_add_product_installs() -> ::ProductInstall* {
  return product_installs_.Add();
}
inline auto ProductDb::add_product_installs() -> ::ProductInstall* {
  // @@protoc_insertion_point(field_add:ProductDb.product_installs)
  return _internal_add_product_installs();
}
inline auto
ProductDb::product_installs() const -> const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProductInstall >& {
  // @@protoc_insertion_point(field_list:ProductDb.product_installs)
  return product_installs_;
}

// repeated .InstallHandshake active_installs = 2;
inline auto ProductDb::_internal_active_installs_size() const -> int {
  return active_installs_.size();
}
inline auto ProductDb::active_installs_size() const -> int {
  return _internal_active_installs_size();
}
inline void ProductDb::clear_active_installs() {
  active_installs_.Clear();
}
inline auto ProductDb::mutable_active_installs(int index) -> ::InstallHandshake* {
  // @@protoc_insertion_point(field_mutable:ProductDb.active_installs)
  return active_installs_.Mutable(index);
}
inline auto
ProductDb::mutable_active_installs() -> ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::InstallHandshake >* {
  // @@protoc_insertion_point(field_mutable_list:ProductDb.active_installs)
  return &active_installs_;
}
inline auto ProductDb::_internal_active_installs(int index) const -> const ::InstallHandshake& {
  return active_installs_.Get(index);
}
inline auto ProductDb::active_installs(int index) const -> const ::InstallHandshake& {
  // @@protoc_insertion_point(field_get:ProductDb.active_installs)
  return _internal_active_installs(index);
}
inline auto ProductDb::_internal_add_active_installs() -> ::InstallHandshake* {
  return active_installs_.Add();
}
inline auto ProductDb::add_active_installs() -> ::InstallHandshake* {
  // @@protoc_insertion_point(field_add:ProductDb.active_installs)
  return _internal_add_active_installs();
}
inline auto
ProductDb::active_installs() const -> const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::InstallHandshake >& {
  // @@protoc_insertion_point(field_list:ProductDb.active_installs)
  return active_installs_;
}

// repeated .ActiveProcess active_processes = 3;
inline auto ProductDb::_internal_active_processes_size() const -> int {
  return active_processes_.size();
}
inline auto ProductDb::active_processes_size() const -> int {
  return _internal_active_processes_size();
}
inline void ProductDb::clear_active_processes() {
  active_processes_.Clear();
}
inline auto ProductDb::mutable_active_processes(int index) -> ::ActiveProcess* {
  // @@protoc_insertion_point(field_mutable:ProductDb.active_processes)
  return active_processes_.Mutable(index);
}
inline auto
ProductDb::mutable_active_processes() -> ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ActiveProcess >* {
  // @@protoc_insertion_point(field_mutable_list:ProductDb.active_processes)
  return &active_processes_;
}
inline auto ProductDb::_internal_active_processes(int index) const -> const ::ActiveProcess& {
  return active_processes_.Get(index);
}
inline auto ProductDb::active_processes(int index) const -> const ::ActiveProcess& {
  // @@protoc_insertion_point(field_get:ProductDb.active_processes)
  return _internal_active_processes(index);
}
inline auto ProductDb::_internal_add_active_processes() -> ::ActiveProcess* {
  return active_processes_.Add();
}
inline auto ProductDb::add_active_processes() -> ::ActiveProcess* {
  // @@protoc_insertion_point(field_add:ProductDb.active_processes)
  return _internal_add_active_processes();
}
inline auto
ProductDb::active_processes() const -> const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ActiveProcess >& {
  // @@protoc_insertion_point(field_list:ProductDb.active_processes)
  return active_processes_;
}

// repeated .ProductConfig product_configs = 4;
inline auto ProductDb::_internal_product_configs_size() const -> int {
  return product_configs_.size();
}
inline auto ProductDb::product_configs_size() const -> int {
  return _internal_product_configs_size();
}
inline void ProductDb::clear_product_configs() {
  product_configs_.Clear();
}
inline auto ProductDb::mutable_product_configs(int index) -> ::ProductConfig* {
  // @@protoc_insertion_point(field_mutable:ProductDb.product_configs)
  return product_configs_.Mutable(index);
}
inline auto
ProductDb::mutable_product_configs() -> ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProductConfig >* {
  // @@protoc_insertion_point(field_mutable_list:ProductDb.product_configs)
  return &product_configs_;
}
inline auto ProductDb::_internal_product_configs(int index) const -> const ::ProductConfig& {
  return product_configs_.Get(index);
}
inline auto ProductDb::product_configs(int index) const -> const ::ProductConfig& {
  // @@protoc_insertion_point(field_get:ProductDb.product_configs)
  return _internal_product_configs(index);
}
inline auto ProductDb::_internal_add_product_configs() -> ::ProductConfig* {
  return product_configs_.Add();
}
inline auto ProductDb::add_product_configs() -> ::ProductConfig* {
  // @@protoc_insertion_point(field_add:ProductDb.product_configs)
  return _internal_add_product_configs();
}
inline auto
ProductDb::product_configs() const -> const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProductConfig >& {
  // @@protoc_insertion_point(field_list:ProductDb.product_configs)
  return product_configs_;
}

// .DownloadSettings download_settings = 5;
inline auto ProductDb::_internal_has_download_settings() const -> bool {
  return this != internal_default_instance() && download_settings_ != nullptr;
}
inline auto ProductDb::has_download_settings() const -> bool {
  return _internal_has_download_settings();
}
inline void ProductDb::clear_download_settings() {
  if (GetArena() == nullptr && download_settings_ != nullptr) {
    delete download_settings_;
  }
  download_settings_ = nullptr;
}
inline auto ProductDb::_internal_download_settings() const -> const ::DownloadSettings& {
  const ::DownloadSettings* p = download_settings_;
  return p != nullptr ? *p : *reinterpret_cast<const ::DownloadSettings*>(
      &::_DownloadSettings_default_instance_);
}
inline auto ProductDb::download_settings() const -> const ::DownloadSettings& {
  // @@protoc_insertion_point(field_get:ProductDb.download_settings)
  return _internal_download_settings();
}
inline void ProductDb::unsafe_arena_set_allocated_download_settings(
    ::DownloadSettings* download_settings) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(download_settings_);
  }
  download_settings_ = download_settings;
  if (download_settings != nullptr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProductDb.download_settings)
}
inline auto ProductDb::release_download_settings() -> ::DownloadSettings* {
  
  ::DownloadSettings* temp = download_settings_;
  download_settings_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline auto ProductDb::unsafe_arena_release_download_settings() -> ::DownloadSettings* {
  // @@protoc_insertion_point(field_release:ProductDb.download_settings)
  
  ::DownloadSettings* temp = download_settings_;
  download_settings_ = nullptr;
  return temp;
}
inline auto ProductDb::_internal_mutable_download_settings() -> ::DownloadSettings* {
  
  if (download_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::DownloadSettings>(GetArena());
    download_settings_ = p;
  }
  return download_settings_;
}
inline auto ProductDb::mutable_download_settings() -> ::DownloadSettings* {
  // @@protoc_insertion_point(field_mutable:ProductDb.download_settings)
  return _internal_mutable_download_settings();
}
inline void ProductDb::set_allocated_download_settings(::DownloadSettings* download_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete download_settings_;
  }
  if (download_settings != nullptr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(download_settings);
    if (message_arena != submessage_arena) {
      download_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, download_settings, submessage_arena);
    }
    
  } else {
    
  }
  download_settings_ = download_settings;
  // @@protoc_insertion_point(field_set_allocated:ProductDb.download_settings)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::LanguageOption> : ::std::true_type {};
template <>
inline auto GetEnumDescriptor< ::LanguageOption>() -> const EnumDescriptor* {
  return ::LanguageOption_descriptor();
}
template <> struct is_proto_enum< ::LanguageSettingType> : ::std::true_type {};
template <>
inline auto GetEnumDescriptor< ::LanguageSettingType>() -> const EnumDescriptor* {
  return ::LanguageSettingType_descriptor();
}
template <> struct is_proto_enum< ::ShortcutOption> : ::std::true_type {};
template <>
inline auto GetEnumDescriptor< ::ShortcutOption>() -> const EnumDescriptor* {
  return ::ShortcutOption_descriptor();
}
template <> struct is_proto_enum< ::Operation> : ::std::true_type {};
template <>
inline auto GetEnumDescriptor< ::Operation>() -> const EnumDescriptor* {
  return ::Operation_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_schema_2eproto
